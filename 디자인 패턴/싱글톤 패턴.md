# 01. 싱글톤 패턴
- 애플리케이션이 시작될 때, 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴
- 즉, '하나'의 인스턴스만을 생성하여 사용하는 디자인 패턴
- 자바에서는 생성자를 private으로 선언해 다른 곳에서 생성하지 못하도록 만들고, getInstance() 메소드를 통해 받아서 사용하도록 구현

### 사용하는 이유
- 객체를 생성할 때마다 메모리 영역을 할당받아야 함. 싱글톤 패턴은 한번의 new를 통해 객체를 생성하여 메모리 낭비를 방지
- 싱글톤으로 구현한 인스턴스는 '전역'이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능

### 주로 사용하는 경우
- 공통된 객체를 여러 개 생성해서 사용해야 하는 상황
- 데이터베이스에서 커넥션 풀, 스레드 풀, 캐시, 로그 기록 객체 등
- 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 때 사용
- 리소르를 많이 차지하는 역할을 하는 무거운 클래스의 전역변수화

### 단점
- 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스들 간의 결합도가 높아질 수 있음
- 객체 지향 설계 원칙 중 '개방-폐쇄 원칙' 위배 가능
- 결합도가 높아지면, 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제 발생
- 멀티 스레드 환경에서 동기화 처리를 하지 않았을 때, 인스턴스가 2개 생성되는 문제 발생
- 따라서, 반드시 싱글톤이 필요한 상황이 아니면 지양


# 02. 멀티스레드 환경에서 안전한 싱글톤 만드는법
## (1) Eager Initialization
<img width="564" alt="image" src="https://github.com/user-attachments/assets/8b321916-aebf-44bc-86a8-4a0a5bd1ba65" />

- 한번만 미리 만들어두는, 가장 직관적이면서도 심플한 기법
- static final -> 멀티 스레드 환경에서도 안전
- 단, static 멤버는 당장 객체를 사용하지 않더라도 메모리에 적재하기 때문에 리소스가 큰 객체일 경우, 공간 자원 낭비 발생
- 예외 처리를 할 수 없음


## (2) static block initialization
<img width="528" alt="image" src="https://github.com/user-attachments/assets/1286d886-6c75-4554-9a6e-37d38df7a824" />

- static block(클래스가 로딩되고 클래스 변수가 준비된 후 자동으로 실행되는 블록)을 이용해 예외를 잡을 수 있음
- 그러나 여전히 static의 특성을 가지고 있어 사용하지 않아도 공간을 차지함


## (3) Lazy Initialization (게으른 초기화)
<img width="558" alt="image" src="https://github.com/user-attachments/assets/37864dcc-5538-4ded-87f7-d1efd209bca0" />

- private static으로 인스턴스 변수를 만듦
- private으로 생성자를 만들어 외부에서의 생성을 막음 (객체 생성에 대한 관리를 내부적으로 처리)
- 메서드를 호출했을 때 인스턴스 변수의 null 유무에 따라 초기화하거나 있는 걸 반환하는 기법
- static 사용기법들의 미사용 고정 메모리 차지의 한계점을 극복
- 그러나 Thread Safe X

### 멀티 스레드 환경에서의 치명적인 문제점
- 싱글톤 패턴 정석 ?
- 자바는 멀티 스레드 언어인데, 이 멀티 스레드 환경에서 스레드 세이프 하지 않다는 치명적인 문제점을 가짐
- 각 스레드는 자신의 실행 단위를 기억하면서 코드를 위에서 아래로 읽어간다. 따라서 동시성으로 인한 코드 실행 문제점 발생 가능

<img width="504" alt="image" src="https://github.com/user-attachments/assets/a0a746a2-4dd1-486f-af37-0a88d9db1069" />

1. 스레드 A, 스레드 B가 존재
2. 스레드 A가 if문을 평가하고 인스턴스 생성 코드로 진입(초기화 전)
3. 이때 스레드 B가 if문을 평가함. 아직 스레드 A가 인스턴스화 코드를 실행하기 전이기 때문에 이 if문이 참이 되어버림
4. 결과적으로 스레드 A, B 모두 인스턴스 초기화 코드를 실행하는 꼴이 됨 => 원자성 결여


## (4) Thread safe Initialization
<img width="500" alt="image" src="https://github.com/user-attachments/assets/bd46559a-5f0a-4166-b718-82e9dbcef28e" />

- synchronized 키워드를 통해 메서드에 쓰레드들을 하나하나씩 접근하게 하도록 설정(동기화)
- 하지만 여러 개의 모듈들이 매번 객체를 가져올 때 synchronized 메소드를 매번 호출하여 동기화 처리 작업에 overhead -> 성능 하락 발생

### synchorized
<img width="575" alt="image" src="https://github.com/user-attachments/assets/bd3d29b3-d3e4-47d7-a20f-ab24842956b1" />

- synchronized 키워드는 멀티 스레드 환경에서 두 개 이상의 스레드가 하나의 변수에 동시에 접근할 때 경쟁상태가 발생하지 않도록 함
- 스레드가 해당 메서드를 실행하는 동안 다른 스레드가 접근하지 못하도록 잠금(lock)을 거는 것
- thread-1이 메서드에 진입하는 순간, 나머지 thread 2~4의 접근을 제한하고, thread-1이 완료가 되면 다음 스레드 접근시킴


## (5) Double-Checked Locking
<img width="884" alt="image" src="https://github.com/user-attachments/assets/e92e902b-b89c-4b87-8727-96727c6a5a5c" />

- 매번 synchronized 동기화를 실행하는 것이 문제라면, 최초 초기화할 때만 적용하고 이미 만들어진 인스턴스를 반환할 때는 사용하지 않도록 하는 기법
- 이때 인스턴스 필드에 volatile 키워드를 붙여주어야 I/O 불일치 문제를 해결할 수 있음
- 하지만, volatile 키워드를 이용하기 위해서는 JVM 1.5 이상이어야 하고, JVM에 대한 심층적 이해가 필요하기 때문에 사용을 지양하는 편

### volatile 키워드
- 자바에서 스레드를 여러 개 사용할 경우, 성능을 위해서 각각의 스레드들은 RAM에서 가져오는 것이 아니라 캐시 메모리에서 가져오게 됨
- 문제는, 비동기로 변수값을 캐시에 저장하다가, 각 스레드마다 할당되어 있는 캐시 메모리의 변수 값이 일치하지 않을 수 있다는 것
- 그래서 volatile 키워드를 통해 이 변수는 캐시에서 읽지 말고 메인 메모리에서 읽어오도록 지정


## (6) Bill Pugh Solution (LazyHolder)
- 권장되는 두 가지 방법중 하나
- 멀티 스레드 환경에서 안전하고 Lazy Loading(나중에 객체 생성)도 가능한 완벽한 싱글톤 기법
- 클래스 안에 내부 클래스(holder)로 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방법
- static 메소드에서는 static 멤버만을 호출할 수 있기 때문에 내부 클래스를 static으로 설정
- 이밖에도 내부 클래스의 치명적인 문제점인 메모리 누수 문제를 해결하기 위해 내부 클래스를 static으로 설정
- 다만, 클라이언트가 임의로 싱글톤을 파괴할 수 있다는 단점 존재(Reflection API, 직렬화/역직렬화 통해)
- 
<img width="775" alt="image" src="https://github.com/user-attachments/assets/42b6f766-4493-42be-9adf-5fdfb577fabc" />

1. 우선 내부 클래스를 static으로 선언하였기 때문에 싱글톤 클래스가 초기화되어도 SingleInstanceHolder 내부 클래스는 메모리에 로드X
2. 어떠한 모듈에서 getInstance() 메서드를 호출할 때, Single/instanceHolder 내부 클래스의 static 멤버를 가져와 리턴하게 되는데, 이때 내부 클래스가 한번만 초기화되면서 싱글톤 객체를 최초로 생성 및 리턴하게 됨
3. 마지막으로 final로 지정함으로써 다시 값이 할당되지 않도록 방지


## (7) Enum 이용
- 권장되는 두 가지 방법중 하나
- enum은 애초에 멤버를 만들 때 private로 만들고 한번만 초기화하기 때문에 thread safe함
- enum 내에서 상수 뿐만 아니라 변수나 메서드를 선언해 사용이 가능하기 때문에 싱글톤 클래스 처럼 응용 가능
- Bill Pugh Solution 기법과 달리, 클라이언트에서 Reflection을 통한 공격에도 안전
- 하지만, 만일 싱글톤 클래스를 멀티톤(일반적인 클래스)로 마이그레이션 해야할 때 처음부터 코드를 다시 짜야되는 단점 존재
- 클래스 상속이 필요할 때, enum 외의 클래스 상속이 불가능

<img width="524" alt="image" src="https://github.com/user-attachments/assets/cfa700f5-24c6-4c8d-afa0-bdf12a387a84" />


=> 싱글톤 패턴 클래스를 만들기 위해서는 Bill Pugh Solution 기법을 사용하거나 Enum으로 만들어 사용
- LazyHolder : 성능이 중요시 되는 환경
- Enum : 직렬화, 안정성 중요시 되는 환경

## 그렇다면 ?
- 스프링 컨테이너 같은 프레임워크의 도움을 받으면 싱글톤 패턴의 문제점들을 보완하면서 장점의 혜택을 누릴 수 있음
- 스프링 프레임워크에서는 싱글톤 패턴이 없고, 내부적으로 클래스의 제어를 IoC(Inversion Of Control)방식의 컨테이너에게 넘겨 컨테이너가 관리하기 때문에,
- 이를 통해 평범한 객체도 하나의 인스턴스 뿐인 싱글턴으로 존재가 가능하기 때문에 싱글톤 단점이 없음

# 03. 자주 나오는 질문
### (1) 싱글톤 패턴이란 무엇이며, 왜 사용하는가 ?
싱글톤 패턴은 객체의 인스턴스를 하나만 생성하도록 보장하는 디자인 패턴입니다.
주로 전역적으로 접근이 필요한 공유 자원을 관리할 때 사용됩니다.
메모리 절약, 전역 상태 유지, 동기화 문제 해결을 위해 사용합니다.

### (2) 싱글톤 패턴을 구현할 때 고려해야 할 주요 문제점은 ?
1.	멀티스레드 환경에서 동시 접근 문제
  - 두 개의 스레드가 동시에 인스턴스를 생성하려 하면 두 개의 인스턴스가 생성될 가능성이 있음
  - 해결법: 이중 체크 락킹(Double-Checked Locking) 기법 또는 정적 초기화(Static Initialization) 기법 사용
2.	테스트하기 어려움 (의존성 주입 문제)
  - 싱글톤은 전역 인스턴스를 유지하므로, 테스트에서 객체를 쉽게 교체하기 어려움
  - 해결법: **의존성 주입(DI, Dependency Injection)**을 통해 인터페이스 기반으로 관리
3.	클래스 로더 및 리플렉션(Reflection) 문제
  - 리플렉션을 사용하면 private 생성자를 강제로 호출하여 새로운 인스턴스 생성 가능
  - 해결법: 생성자에서 기존 인스턴스가 존재하면 예외를 발생하도록 구현

### (3) 자바에서 싱글톤을 구현하는 가장 안전한 방법은 ?
- Enum : 멀티 스레드 환경에서 안전, 리플렉션 공격 방어 가능, 직렬화 시에도 단일 인스턴스 유지
- Lazy Holder : 클래스가 로드될 때  인스턴스를 생성하지 않으며, getInstance()가 처음 호출될 때 생성됨. 멀티 스레드 환경에서 안전, 동기화 비용X


### 참고
https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%8B%B1%EA%B8%80%ED%86%A4Singleton-%ED%8C%A8%ED%84%B4-%EA%BC%BC%EA%BC%BC%ED%95%98%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
