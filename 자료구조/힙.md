# 01. 힙의 개념

완전이진트리를 기본으로 한 자료구조

→ 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안

→ 다음과 같은 속성을 만족함

• A가 B의 부모노드(parent node) 이면, A의 키(key)값과 B의 키 값 사이에는 대소관계가 성립한다.

## 힙의 종류
![img](https://github.com/user-attachments/assets/5a349ff5-a129-420e-8e59-f46ece896860)

- 최대 힙 : `부모 노드의 키 값 > 자식 노드의 키 값` 을 항상 만족
- 최소 힙 : `부모 노드의 키 값 < 자식 노드의 키 값` 을 항상 만족

키 값의 대소 관계는 부모-자식 간에만 성립, 형제 사이에서는 X

⇒ 힙을 사용하면 가장 높거나, 가장 낮은 우선순위의 노드가 항상 root 노드에 옴

⇒ 이를 응용하여 **우선순위 큐**와 같은 추상적 자료형 구현 가능

# 02. 힙의 구현

## 구현

- 힙을 저장하는 표준적인 자료구조는 **배열**
- 구현의 편의성을 위해 첫 번째 인덱스인 0을 비움

## 이진 힙의 특징

1. 뿌리 노드를 제외한 각 내부노드는 부모 자식 노드 간 일정한 대소 관계를 가짐
    - 현재 노드 인덱스: $i$
    - 부모 노드 인덱스: $i/2$
    - 왼쪽 자식 인덱스: $2×i$
    - 오른쪽 자식 인덱스: $2×i+1$
2. **완전 이진 트리** 형태로 모든 레벨이 완전히 채워져 있으며, 마지막 레벨은 왼쪽에서 오른쪽으로 채워짐
3. 중복을 허용함

![heap-index-parent-child](https://github.com/user-attachments/assets/ce299882-220f-4ec8-a4be-817e68ba3493)

## 주요 연산

### 삽입

- 새로운 요소를 힙의 가장 마지막 위치에 추가
- 부모와 비교하여 힙 속성을 만족할 때까지 위치 조정
- 시간 복잡도:  O(log n)

```java
void insert_max_heap(int x) {
    
    maxHeap[++heapSize] = x; 
    // 힙 크기를 하나 증가하고, 마지막 노드에 x를 넣음
    
    for( int i = heapSize; i > 1; i /= 2) {
        
        // 마지막 노드가 자신의 부모 노드보다 크면 swap
        if(maxHeap[i/2] < maxHeap[i]) {
            swap(i/2, i);
        } else {
            break;
        }
        
    }
}
```
![maxheap-insertion](https://github.com/user-attachments/assets/64856721-3fa3-481e-9faf-45b79318f770)


### 삭제

- 루트 노드를 삭제 (최대 힙에서의 삭제 연산 = 최대값 요소 삭제)
- 마지막 노드를 루트로 이동시키고 자식과 비교하여 힙 속성을 만족할 때까지 위치 조정
- 시간 복잡도:  O(log n)

```java
int delete_max_heap() {
    
    if(heapSize == 0) // 배열이 비어있으면 리턴
        return 0;
    
    int item = maxHeap[1]; // 루트 노드의 값을 저장
    maxHeap[1] = maxHeap[heapSize]; // 마지막 노드 값을 루트로 이동
    maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드 0 초기화
    
    for(int i = 1; i*2 <= heapSize;) {
        
        // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 끝
        if(maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
            break;
        }
        
        // 왼쪽 노드가 더 큰 경우, swap
        else if (maxHeap[i*2] > maxHeap[i*2+1]) {
            swap(i, i*2);
            i = i*2;
        }
        
        // 오른쪽 노드가 더 큰 경우
        else {
            swap(i, i*2+1);
            i = i*2+1;
        }
    }
    
    return item;
    
}
```
![maxheap-delete](https://github.com/user-attachments/assets/fc90476a-a74e-4e1b-9995-c960de44e2a6)

# 03. 자주 나오는 질문 정리

### Heap에 대해서 설명해주세요.

힙은 우선순위 큐를 구현하기 위해 고안된 완전이진트리 형태의 자료구조입니다.

힙의 특징은 완전이진트리 형태라는 것과 부모노드와 서브트리간의 대소 관계가 성립한다는 것 그리고 중복 값이 허용된다는 것입니다. 

또한, 힙은 크게 두 가지 종류로 나눌 수 있는데 최대 힙의 경우에는 부모 노드의 키 값이 자식 노드보다 크거나 같은 완전이진트리이고 최소 힙의 경우에는 부모 노드의 키 값이 자식 노드보다 작거나 같은 완전이진트리입니다.

힙의 삽입 삭제 시간 복잡도는 O(logn)이며 힙 정렬의 시간 복잡도는 O(nlogn)입니다.

### 힙과 이진탐색트리(BST)의 차이점은 무엇인가요?

힙과 이진 탐색 트리는 모두 이진 트리 구조를 기반으로 하지만, 용도와 동작 원리가 다릅니다.

- 힙(Binary Heap)은 **완전 이진 트리**로, 최대 힙에서는 부모 노드가 자식 노드보다 크거나 같아야 하는 힙 속성을 유지합니다. 하지만 노드들은 정렬 순서가 아닌 힙 속성만 유지하기 때문에 같은 레벨이나 자식 간에는 순서가 보장되지 않습니다.
- 이진 탐색 트리(BST)는 **탐색**을 목적으로 하며, 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 크다는 속성을 유지해 정렬된 트리 구조를 만듭니다.

이 차이로 인해 힙은 빠른 최대/최소 값 추출이 필요한 경우 적합하며,

BST는 검색, 삽입, 삭제 연산을 효율적으로 수행할 때 적합합니다.

### PriorityQueue는 힙을 사용하여 어떻게 구현하나요?

우선순위 큐(Priority Queue)는 힙을 사용하여 효율적으로 구현할 수 있습니다. 

**최대 힙**을 사용하면 가장 높은 우선순위를 가진 요소를 빠르게 추출할 수 있고, **최소 힙**을 사용하면 가장 낮은 우선순위의 요소를 빠르게 추출할 수 있습니다.

1. **삽입(Enqueue)**: 새로운 요소를 우선순위 큐에 추가할 때, 힙의 가장 마지막 위치에 삽입한 뒤 힙 속성을 유지하기 위해 상향 이동(Up-Heap)을 수행하여 부모와 비교하며 위치를 조정합니다. 삽입 연산의 시간복잡도는 O(log n)입니다.
2. **삭제(Dequeue)**: 최우선 요소를 삭제할 때는 루트 노드(최대 힙에서 최댓값 또는 최소 힙에서 최솟값)를 제거하고 마지막 요소를 루트로 옮긴 후, 하향 이동(Down-Heap)을 수행해 자식과 비교하며 위치를 조정하여 힙 속성을 복구합니다. 삭제 연산의 시간복잡도도 O(log n)입니다.

힙을 사용한 우선순위 큐는 삽입과 삭제 연산 모두 효율적으로 처리할 수 있어 실시간 데이터 처리, 작업 스케줄링 등에 유용하게 사용됩니다.

### 참고

- https://gyoogle.dev/blog/computer-science/data-structure/Heap.html
- [https://ko.wikipedia.org/wiki/힙_(자료_구조)](https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0))
- [https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)
