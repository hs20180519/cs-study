# 00. 다원 탐색 트리(multiway search tree)

- 이원 탐색 트리(AVL, red-black 트리)는 원소의 개수가 n일 때, $O(logn)$시간 안에 검색, 삽입, 삭제가 가능함
- 현대 컴퓨터에서의 메모리(메인 메모리 or 디스크) 접근이 산술이나 논리 연산을 수행하는 것보다 더 많은 시간이 걸림
    
    → 이 점을 이용하면 탐색 구조의 성능을 향상시킬 수 있음
    
- 탐색 트리의 높이와 메모리 접근 횟수는 밀접한 상관 관계가 있으므로, 탐색 트리의 높이를 줄이는 것이 핵심
- 데이터 전송 단위
    - 디스크↔메인 메모리: 블록 단위(수 KB)
    - 메인 메모리 ↔ CPU 캐시: 캐시 라인 단위(수백 byte)

![image](https://github.com/user-attachments/assets/82a0da8a-02a0-43c3-959b-61f23753eca0)

- 하지만, AVL 트리나 red-black 트리에서는 노드 크기가 일반적으로 몇 byte밖에 되지 않기 때문에 위와 같은 전송 단위를 사용하는 것이 효율적이지 않음
    
    → 트리의 특정 노드 하나에 접근하고자 할 때 그 노드가 메모리상에서 다른 노드와 가까이 있지 않을 수 있는데, 하나의 노드를 가져오기 위해 블록 단위로 데이터를 가져오더라도 실제로 필요한 노드는 그중 극히 일부일 수 있기 때문에 블록의 나머지 데이터는 불필요해짐
    
- e.g. 1,000,000개의 원소를 가진 AVL 트리
    - 트리의 높이는 $1.44log_2(n+2)=28$ 정도가 될 것
    - 이 트리에서 특정 키를 가진 원소를 검색하려면, 루트에서부터 찾는 원소가 있는 노드까지의 탐색 경로에 있는 노드들에 접근해야 함
    - 최악의 경우: 탐색 경로에 28개의 노드가 포함되어 있고, 28개의 노드가 각각 다른 메모리 블록에 위치
        
        → 28번의 비교와 28번의 메모리 접근이 이루어짐
        
    
    ⇒ 성능을 향상시키려면 메모리 접근 횟수를 줄여야 함
    
- 이원 탐색 트리를 이용하면 트리 높이가 $log_2(n+1)$로 커짐
    
    → 이를 개선하기 위해서 차수가 2보다 큰 탐색 트리를 이용
    
- 트리 노드들이 하나의 캐시 라인이나 디스크 블록을 채울 수 있는 가장 큰 차수를 사용

## 특징

- 각 노드는 0개 이상 m개 이하의 서브 트리를 가짐
- k개의 자식노드를 가지는 노드는 k-1개의 요소를 가짐
- 각 노드 안에 존재하는 키는 오름차순으로 정렬됨
- 항상 다음 조건을 만족한다:
    
    i번째 key < i번째 서브트리 내의 모든 key값 < i+1번째 key
    
- 모든 서브트리는 다원 탐색 트리임

## 장단점

- 트리의 높이를 낮춤으로써 탐색 속도를 높일 수 있음
- 스스로 균형을 유지하지 못함
    
    → 불균형이 발생하여 검색 성능이 떨어질 수 있음
    
    → 이 단점을 보완하기 위해, 스스로 균형을 유지하는 b-tree가 등장
    

# 01. B-Tree

- 탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종
- 모든 leaf node가 같은 level로 유지되도록 자동으로 균형을 맞춤
- 최대 M개의 자식을 가질 수 있는 B-tree를 M차 B-tree라고 함

## 조건

- node의 key 개수가 k개라면, 자식 node의 수는 k+1개
- node의 key는 반드시 정렬된 상태여야 함
- 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉨
- root node가 leaf node인 경우를 제외하고, root node는 항상 2개 이상의 자식 node를 가짐
- M차 트리일 때, root node와 leaf node를 제외한 모든 node는 최소 $\frac{M}{2}$, 최대 M개의 자식을 가짐

![image (1)](https://github.com/user-attachments/assets/b361692b-a696-4795-9f63-6a522cd2754a)
3차 b-tree

### 노드의 구성

- key: 데이터를 정렬하고 식별하는 기준
- data: key값에 해당하는 실제 정보
- pointer: 자식 노드를 가리킴

## 검색

- root node에서 시작하여 하향식으로 검색
- 검색하고자 하는 key를 $k$라고 했을 때의 검색 과정:
    1. 루트 노드부터 key를 순회하면서 검사
        1. $k$와 같은 key를 찾았다면 검색을 종료
        2. $k$와 key들의 대소관계를 비교하여, 특정 key값들 사이에 $k$가 들어간다면 해당 key들 사이의 자식노드로 내려감
    2. 해당 과정을 leaf node에 도달할 때까지 반복
    3. leaf node에도 $k$와 같은 key가 없다면 검색에 실패함

### e.g. 18 검색

![image (2)](https://github.com/user-attachments/assets/94becfa6-4099-42a8-bfe7-ec09529a0be1)

1. root noe의 key를 순회하면서 검색 시작
2. 18은 10보다 큼 → 다음 key 검사
3. 다음 key인 20보다 작음 → 10과 20 사이의 자식 노드로 이동
4. 자식 노드에서 다시 검색 시작: 노드의 마지막 key인 17보다 크기 때문에 노드의 가장 마지막 자식 노드로 이동
5. 18 검색 완료

## 삽입

- **1. 요소 삽입에 적절한 리프 노드를 검색(상향식)**하고, **2. 필요한 경우 노드를 분할(하향식)**해야 함
- 삽입하고자 하는 값을 $k$라고 했을 때의 삽입 과정:
    1. 트리가 비어있으면 루트 노드를 할당하고 $k$를 삽입
        1. 루트노드가 가득찼다면 노드를 분할하고 리프노드를 생성
    2. 이후부터는 삽입하기에 적절한 leaf node를 찾아 $k$를 삽입
        1. 삽입 위치: 노드의 key값과 $k$값을 검샌 연산과 동일한 방법으로 비교하여 찾음

### case 1. 분할이 일어나지 않는 경우

- leaf node가 가득차지 않았다면, **오름차순으로 $k$를 삽입**

**e.g. 9 삽입**

![image (3)](https://github.com/user-attachments/assets/6ff908ef-94e1-4e4f-8b66-ff670e19709d)

1. root node: 10 > 9이므로, 가장 왼쪽 자식 노드로 이동
2. 5 < 9 이므로, 가장 오른쪽 자식 노드로 이동
3. 리프노드에 도달, 9 >7 이므로 7 오른쪽에 9 삽입

![image (4)](https://github.com/user-attachments/assets/04be5954-5a25-47f6-8a1e-774261e3347c)

### case 2. 분할이 일어나는 경우

- leaf node에 key 노드가 가득 찬 경우, 노드를 분할해야 함
1. 오름차순으로 요소 삽입
2. 중앙값에서 분할 수행
    1. 중앙값은 부모 노드로 병합하거나 새로 생성
    2. 왼쪽 키들은 왼쪽 자식으로, 오른쪽 키들은 오른쪽 자식으로 분할
3. 병합된 부모 노드가 가득찼다면, 다시 부모노드에서 위 과정을 반복

**e.g. 13 삽입**


![image (3)](https://github.com/user-attachments/assets/6ff908ef-94e1-4e4f-8b66-ff670e19709d)


1. root node의 key 중 10보다 크고 20보다 작기 때문에, 중간 자식노드로 이동
2. 14보다 작기 때문에, 가장 왼쪽 자식노드로 이동
3. 12보다 크기 때문에, 가장 마지막에 삽입

![image (5)](https://github.com/user-attachments/assets/43238240-c8b4-47cb-b562-42d61e627889)

1. 해당 노드가 최대로 가질 수 있는 key의 개수를 초과 → **중앙값 12**를 기준으로 분할
2. 12는 부모노드에 오름차순으로 삽입. 11과 13은 12의 각각 왼쪽 자식, 오른쪽 자식으로 설정
3. 12가 병합된 노드가 최대로 가질 수 있는 key의 개수를 초과 → **중앙값 14**를 기준으로 분할
4. 14가 새로운 root node가 되고, 10과 20은 14의 왼쪽 자식, 오른족 자식으로 설정

![image (6)](https://github.com/user-attachments/assets/959e5b41-0a7e-4dbf-b68b-de9e33dcefdd)

## 삭제

1. 삭제할 키가 있는 노드 검색
2. 2. 키 삭제
3. 3. 필요한 경우 트리 균형 조정

**참고 용어**

- inorder predecessor: 노드의 왼쪽 **자손**에서 가장 큰 key
- inorder successor: 노드의 오른쪽 **자손**에서 가장 작은 key
- 부모 key: 부모 노드의 key 중 본인 노드를 왼쪽 자식으로 가지고 있는 key. 단, 마지막(가장 왼쪽) 자식 노드의 경우 부모의 마지막 key

### case 1. 삭제할 key $k$가 leaf node인 경우

**case 1-1. 현재 노드의 key 개수가 최소 key 개수보다 큰 경우**

- 단순 삭제

![image (7)](https://github.com/user-attachments/assets/87e15300-e03f-4b10-bb0e-229266c7e835)

**case 1-2. 왼쪽 또는 오른쪽 형제 노드의 key가 최소 key 개수 이상일 경우**

1. 부모 key값으로 $k$값을 대체
2. 최소 key 개수 이상의 key를 가진 형제 노드가 왼쪽 형제라면 가장 큰 값을,
    
    오른쪽 형제라면 가장 작은 값을 부모 key로 대체
    
![image (8)](https://github.com/user-attachments/assets/70011d24-78c0-41dd-b4f3-e93bd2d92fb2)


**case 1-3. 왼쪽, 오른쪽 형제 노드의 key가 최소 key 개수이고, 부모 노드의 key가 최소 개수 이상인 경우**

1. $k$를 삭제한 후, 부모 key를 형제 노드와 병합
2. 부모 노드의 key 개수와 자식 수를 하나씩 감소
![image (9)](https://github.com/user-attachments/assets/652675ea-fc27-4640-9124-d7824b49fafa)


**case 1-4. 자신과 형제, 부모 노드의 key 개수가 모두 최소 key 개수인 경우**

- case 3의 2번 과정으로 이동

### case 2. 삭제할 key $k$가 내부 노드에 있고, 노드나 자식의 key가 최소 key 개수보다 많을 경우

1. 현재 노드의 inorder predecessor 또는 inorder successor와 $k$의 자리를 교체
2. leaf node의 $k$를 삭제하면 leaf node가 삭제되었을 때의 조건과 동일해지므로, 삭제된 leaf node에 대해서 case 1로 이동
![image (10)](https://github.com/user-attachments/assets/b136572e-8e0c-4b23-b8b6-70d5c2141028)

### case 3. 삭제할 key $k$가 내부 노드에 있고, 노드의 key 개수와 노드의 자식 key 개수가 모두 최소 key 개수인 경우

- $k$를 삭제하면 트리의 높이가 줄어들어 재구조화가 일어나는 경우이다.

1. $k$를 삭제하고 $k$의 양쪽 자식을 병합하여 하나의 노드(n1)로 만듦
2. $k$의 부모 key를 인접한 형제 노드에 붙임(n2)
3. n1을 n2의 자식이 되도록 연결
4. n2의 key 수가:
    1. 최대보다 크다면, 삽입 연산의 노드 분할 과정을 수행
    2. 최소보다 작다면, n2에 대하여 2번부터 반복

![image (11)](https://github.com/user-attachments/assets/af2a8579-beb5-4ac5-934d-3dfc28d60a65)

# 03. 참고자료
https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree
https://rebro.kr/169
