# 01. 개요

- Selection Sort, 제자리 정렬(in-place) 알고리즘의 하나.
- 리스트를 반복하며 가장 작은 값을 찾아 앞쪽부터 순서대로 정렬하는 방식

# 02. 방법

![images_yewon-july_post_69bef8f8-5c3f-4f56-a3c6-2b2c983bbd72_selection-sort](https://github.com/user-attachments/assets/5c8f7cfc-f520-478d-8df9-7d631d246ca5)

## 소스 코드(Java)

```java
void selectionSort(int[] arr) {
   int minIdx, tmp;
   for (int i = 0; i < arr.length - 1; i++) {
		   minIdx = i;
		   for (int j = i + 1; j < arr.length; j++) {
				   if (arr[j] < arr[minIdx]) {
						   minIdx = j;
				   }
		   }
		   // swap (arr[minIdx], arr[i])
		   tmp = arr[minIdx];
		   arr[minIdx] = arr[i];
		   arr[i] = tmp;
   }
   	
}
```

1. 첫 번째 요소부터 **가장 작은 값 찾기**
    
    리스트의 첫 번째 위치에서 시작해 끝까지 순회하며 가장 작은 값을 탐색
    
2. 첫 번째 요소와 가장 작은 값 **교환**
    
    가장 작은 값이 위치한 인덱스와 현재 첫 번째 위치의 값을 교환함 ⇒ 첫 번째 위치에는 정렬된 요소가 옴
    
3. 다음 위치로 이동해 반복
    
    두 번째 위치로 이동하여 리스트의 나머지 부분에서 가장 작은 값을 찾아 두 번째 위치의 값과 교환
    
4. 리스트의 끝까지 반복

<br />

![selection-sort-001](https://github.com/user-attachments/assets/842dcae5-d2b7-4cdf-9688-5e0b883d5a60)

## 복잡도

| 경우               | 시간 복잡도 | 공간 복잡도 | 설명                                                                                       |
|------------------|-------------|-------------|------------------------------------------------------------------------------------------|
| 최선의 경우         | $O(n^2)$   | $O(1)$    | 선택 정렬은 항상 전체 리스트를 순회하며 최소값을 찾아야 하므로 데이터의 정렬 상태에 관계없이 $O(n^2)$의 시간이 소요됩니다. |
| 평균의 경우         | $O(n^2)$   | $O(1)$    | 선택 정렬의 평균 시간 복잡도는 데이터의 정렬 상태와 무관하게 항상 $O(n^2)$입니다.                                  |
| 최악의 경우         | $O(n^2)$   | $O(1)$    | 데이터가 역순으로 정렬되어 있더라도 선택 정렬은 항상 $O(n^2)$의 시간이 걸립니다.                                      |
| 공간 복잡도 (추가 메모리) | -           | $O(1)$    | 선택 정렬은 주어진 리스트 내에서 교환 작업만 수행하기 때문에 추가 메모리가 거의 필요하지 않습니다.                     |


# 03. 특징

## 장점

- **구현이 단순함**: 알고리즘이 직관적이고 구현이 쉽다.
- **추가 메모리가 거의 필요 없음**: 리스트 내에서 요소를 교환하는 방식으로 진행되므로, 추가적인 메모리 공간을 필요로 하지 않는다. (O(1) 공간 복잡도)
- **데이터 이동이 적음**: 데이터의 교환 횟수가 적고, 비교 연산을 통한 탐색이 주가 되므로 특정 상황에서는 효율적이다. (예: 교환이 비용이 많이 드는 경우)

## 단점

- **느린 시간 복잡도**: 시간 복잡도가 O(n2)로, 데이터가 많아질수록 속도가 급격히 느려지며, 특히 대규모 데이터에 비효율적이다.
- **정렬된 데이터에도 동일한 시간 소요**: 데이터가 이미 정렬되어 있거나 부분적으로 정렬된 경우에도 최선의 시간 복잡도가 O(n2)로 고정되기 때문에, 정렬 상태를 전혀 활용하지 못한다.
- **비교 횟수 많음**: 모든 요소를 비교해 최솟값을 찾기 때문에, 비교 횟수가 많아 속도가 느리다.

# 04. 부록 - 제자리성, 안정성

## In-place Algorithm 제자리 알고리즘
- 추가 메모리를 사용하지 않고 입력 데이터를 직접 조작하여 정렬하는 알고리즘
- ex) 선택 정렬(Selection Sort), 퀵 정렬(Quick Sort), 힙 정렬(Heap Sort)
- 
### 장/단점
- 메모리 사용량이 적어 메모리 제한이 환경에서 유리함
- 추가 메모리를 사용하지 않아 실행 속도가 빠름
- 데이터를 조작하므로 입력 데이터의 손상 가능성

## Stable Sort 안정 정렬
- 중복 요소들의 상대적인 순서가 정렬 후에도 유지되는 정렬 방식

예를 들어, [(3, 'a'), (2, 'b'), (3, 'c')] 와 같은 리스트가 있을 때
첫 번째 요소 기준으로 오름차순 정렬 시
1. [(2, 'b'), (3, 'a'), (3, 'c')]
2. [(2, 'b'), (3, 'c'), (3, 'a')]

1번과 같이 정렬 이전의 (3, 'a')과 (3, 'c') 원래 순서를 유지하는 경우 -> Stable
2번과 같이 정렬 이전과 순서가 달라지는 경우 -> Unstable

| Stable Sort 알고리즘        | Unstable Sort 알고리즘   |
|-----------------------------|--------------------------|
| 버블 정렬 (Bubble Sort)      | 선택 정렬 (Selection Sort) |
| 병합 정렬 (Merge Sort)       | 퀵 정렬 (Quick Sort)       |
| 삽입 정렬 (Insertion Sort)   | 힙 정렬 (Heap Sort)        |
| 계수 정렬 (Counting Sort)    | 셸 정렬 (Shell Sort)       |
| 기수 정렬 (Radix Sort)       |                          |

=> Stable Sort는 데이터의 순서를 유지, Unstable Sort는 순서를 보장하지 않음


# 05. 자주 나오는 질문

### 선택 정렬의 시간 복잡도가 $O(n^2)$임에도 사용되는 경우는 언제인가요?
```
선택 정렬은 데이터 양이 적거나 정렬 속도가 덜 중요할 때 유용할 수 있습니다.
특히 추가적인 메모리 사용 없이 정렬을 진행할 수 있기 때문에 메모리가 제한된 환경에서 적합할 수 있습니다.
또한, 교환 연산을 적게 하기 때문에 교환 비용이 높은 상황에서는 상대적으로 유리할 수 있습니다.
```

### 선택 정렬의 시간 복잡도가 $O(n^2)$인 이유는 무엇인가요?
```
선택 정렬은 각 단계에서 남아 있는 리스트의 최솟값을 찾기 위해 모든 요소를 비교합니다.
(n)개의 요소가 있을 때 첫 번째 반복에서는 n번, 두 번째에서는 n-1번, 마지막 단계까지 반복적으로 비교하므로
 (n + (n-1) + (n-2) + ... + 1)과 같은 비교가 필요하게 되어 시간 복잡도가 O(n^2)이 됩니다.
```

### 선택 정렬과 버블 정렬의 차이점은 무엇인가요?
```
선택 정렬은 각 단계에서 최솟값을 찾아 첫 번째 요소와 교환하여 리스트를 정렬합니다. 
반면, 버블 정렬은 인접한 두 요소를 비교하며 큰 값을 뒤로 보내는 방식으로 정렬됩니다. 
선택 정렬은 데이터 이동이 적어 교환이 적게 발생하지만, 전체 탐색을 위해 비교 연산이 많습니다. 
두 알고리즘 모두 시간 복잡도는 O(n^2)로 동일하지만, 데이터 이동과 비교 방식의 차이로 인해 성능이 약간 다를 수 있습니다.
```

### 출처

- [https://ko.wikipedia.org/wiki/선택_정렬](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)
- [https://velog.io/@yewon-july/Selection-Sort](https://velog.io/@yewon-july/Selection-Sort)
- [https://ko.wikipedia.org/wiki/제자리 알고리즘](https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%9E%90%EB%A6%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
