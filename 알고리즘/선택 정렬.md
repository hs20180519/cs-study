# 01. 개요

- Selection Sort, 제자리 정렬(in-place) 알고리즘의 하나.
- 리스트를 반복하며 가장 작은 값을 찾아 앞쪽부터 순서대로 정렬하는 방식

# 02. 방법

![images_yewon-july_post_69bef8f8-5c3f-4f56-a3c6-2b2c983bbd72_selection-sort](https://github.com/user-attachments/assets/5c8f7cfc-f520-478d-8df9-7d631d246ca5)

## 소스 코드(Java)

```java
void selectionSort(int[] arr) {
   int minIdx, tmp;
   for (int i = 0; i < arr.length - 1; i++) {
		   minIdx = i;
		   for (int j = i + 1; j < arr.length; j++) {
				   if (arr[j] < arr[minIdx]) {
						   minIdx = j;
				   }
		   }
		   // swap (arr[minIdx], arr[i])
		   tmp = arr[minIdx];
		   arr[minIdx] = arr[i];
		   arr[i] = tmp;
   }
   	
}
```

1. 첫 번째 요소부터 **가장 작은 값 찾기**
    
    리스트의 첫 번째 위치에서 시작해 끝까지 순회하며 가장 작은 값을 탐색
    
2. 첫 번째 요소와 가장 작은 값 **교환**
    
    가장 작은 값이 위치한 인덱스와 현재 첫 번째 위치의 값을 교환함 ⇒ 첫 번째 위치에는 정렬된 요소가 옴
    
3. 다음 위치로 이동해 반복
    
    두 번째 위치로 이동하여 리스트의 나머지 부분에서 가장 작은 값을 찾아 두 번째 위치의 값과 교환
    
4. 리스트의 끝까지 반복

<br />

![selection-sort-001](https://github.com/user-attachments/assets/842dcae5-d2b7-4cdf-9688-5e0b883d5a60)

## 복잡도

| 경우               | 시간 복잡도 | 공간 복잡도 | 설명                                                                                       |
|------------------|-------------|-------------|------------------------------------------------------------------------------------------|
| 최선의 경우         | $O(n^2)$   | $O(1)$    | 선택 정렬은 항상 전체 리스트를 순회하며 최소값을 찾아야 하므로 데이터의 정렬 상태에 관계없이 $O(n^2)$의 시간이 소요됩니다. |
| 평균의 경우         | $O(n^2)$   | $O(1)$    | 선택 정렬의 평균 시간 복잡도는 데이터의 정렬 상태와 무관하게 항상 $O(n^2)$입니다.                                  |
| 최악의 경우         | $O(n^2)$   | $O(1)$    | 데이터가 역순으로 정렬되어 있더라도 선택 정렬은 항상 $O(n^2)$의 시간이 걸립니다.                                      |
| 공간 복잡도 (추가 메모리) | -           | $O(1)$    | 선택 정렬은 주어진 리스트 내에서 교환 작업만 수행하기 때문에 추가 메모리가 거의 필요하지 않습니다.                     |


# 03. 특징

## 장점

- **구현이 단순함**: 알고리즘이 직관적이고 구현이 쉽다.
- **추가 메모리가 거의 필요 없음**: 리스트 내에서 요소를 교환하는 방식으로 진행되므로, 추가적인 메모리 공간을 필요로 하지 않는다 (O(1) 공간 복잡도).
- **데이터 이동이 적음**: 데이터의 교환 횟수가 적고, 비교 연산을 통한 탐색이 주가 되므로 특정 상황에서는 효율적이다. (예: 교환이 비용이 많이 드는 경우)

## 단점

- **느린 시간 복잡도**: 시간 복잡도가 O(n2)로, 데이터가 많아질수록 속도가 급격히 느려지며, 특히 대규모 데이터에 비효율적입니다.
    
    O(n2)O(n^2)
    
- **정렬된 데이터에도 동일한 시간 소요**: 데이터가 이미 정렬되어 있거나 부분적으로 정렬된 경우에도 최선의 시간 복잡도가 O(n2)로 고정되기 때문에, 정렬 상태를 전혀 활용하지 못합니다.
    
    O(n2)O(n^2)
    
- **비교 횟수 많음**: 모든 요소를 비교해 최솟값을 찾기 때문에, 비교 횟수가 많아 속도가 더딜 수 있습니다.

# 04. 부록 - In-place Algorithm 제자리 알고리즘
- 추가 메모리를 사용하지 않고 입력 데이터를 직접 조작하여 정렬하는 알고리즘
- ex) 선택 정렬(Selection Sort), 퀵 정렬(Quick Sort), 힙 정렬(Heap Sort)

### 장/단점
- 메모리 사용량이 적어 메모리 제한이 환경에서 유리함
- 추가 메모리를 사용하지 않아 실행 속도가 빠름
- 데이터를 조작하므로 입력 데이터의 손상 가능성
### 출처

- [https://ko.wikipedia.org/wiki/선택_정렬](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)
- [https://velog.io/@yewon-july/Selection-Sort](https://velog.io/@yewon-july/Selection-Sort)
- [https://ko.wikipedia.org/wiki/제자리 알고리즘](https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%9E%90%EB%A6%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
