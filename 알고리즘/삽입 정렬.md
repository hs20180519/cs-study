# 01. 개요

- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 넣는 정렬 알고리즘
- 선택 정렬은 정해진 위치에 어떤 원소를 삽입할지 선택하는 것이었다면,
- 삽입 정렬은 정해진 원소를 어떤 위치에 삽입할지 선택하는 것
- 손 안의 카드를 정렬하는 것을 생각하면 쉽다(새로운 카드를 기존에 정렬된 카드 사이 올바른 위치에 삽입)
- 두 번째 원소(index=2)부터 시작하며, 자료의 길이만큼 이동했을 때 정렬이 완성됨

## 동작과정

1. 현재 타겟이 되는 원소와 이전 위치에 있는 원소를 비교한다.
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
3. 그 다음 타겟을 찾아 반복한다.

- 타겟 원소의 이전 원소와 비교하므로 첫 번째 원소는 비교할 대상이 없음
    
    → 두 번째 원소부터 비교하는 이유
![img](https://github.com/user-attachments/assets/a379707f-2c96-471d-a5af-42f876a8f51a)


## 예제

![image](https://github.com/user-attachments/assets/67cb65a1-e9f3-4740-928a-a3098be3cbc4)

```java
public static void insertionSort(int arr[]) {
    for(int i=1;i<arr.length;i++) {
        int target = arr[i];

        int j = i-1;

        // 타겟이 이전 원소보다 크기 전까지 반복
        while(j >= 0 && target < arr[j]) {
            arr[j+1] = arr[j]; // 이전 원소를 한 칸씩 뒤로
            j--;
        }

        arr[j+1] = target;
    }
}
```

### Best case: 배열이 이미 정렬된 경우

**비교횟수**

- 원소들의 이동은 없으며 한 번의 비교(while문 조건)만 이루어짐
    - while문의 조건을 한 번만 수행하고, while문 내부는 수행되지 않음
- n-1번

- 시간복잡도: $O(N)$

### Worst case: 배열이 역순으로 정렬된 경우

**비교횟수**

- j번째 target을 정렬할 때, 부분배열 arr[1, … j-1]과 전부 비교해야 함
- $(n-1)+(n-2)+\dots+2+1=n(n-1)/2$번

- 시간복잡도: $O(N^2)$

## 성능

| best | avg | worst |
| --- | --- | --- |
| $O(N)$ | $O(N^2)$ | $O(N^2)$ |
- 보통 $n^2$의 정렬 알고리즘 중 평균 성능이 가장 좋은 것으로 알려짐

# 02. 특징

- 데이터를 비교하면서 들어갈 자리를 찾음 → 비교 정렬
- 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않음 → 제자리 정렬(in-place sort)
    - 데이터를 교환하는 과정에서 필요로 하는 임시 변수는 무시할 만함
- 안정 정렬: 동일한 값을 가진 원소들의 순서가 입력 순서와 동일하게 유지되는 방법

## 장점

- 안정적(바로 옆의 데이터와 비교하기 때문)
- 자료의 수가 적을 경우 알고리즘 구현이 매우 간단
- **이미 정렬되어 있는 경우나, 자료의 수가 적은 정렬에 매우 효율적**

## 단점

- 레코드들이 비교적 많이 이동함
- 자료의 수가 많고, 크기가 클 경우 적합하지 않음

# 04. 자주 나오는 질문

## 삽입 정렬에 대해 설명해 주세요.

삽입 정렬은 두 번째 값부터 타겟 원소로 지정하고, 그 앞 원소들과 비교해 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다.

자료의 정렬 여부에 굉장히 민감하다는 특징을 가지고 있습니다. 자료가 정렬된 경우가 최선의 경우로 시간복잡도는 $O(N)$이고, 자료가 역순으로 정렬된 경우는 최악의 경우로 시간복잡도가 $O(N^2)$입니다.

## 이미 정렬된 데이터에 대해 가장 좋은 성능을 보이는 정렬 알고리즘은?

삽입 정렬입니다. 자기 앞에 있는 원소에 대해서만 비교를 수행하기 때문에 정렬된 데이터의 경우 $O(N)$이 걸립니다.

## 왜 삽입 정렬이 평균 $O(N^2)$ 시간복잡도를 갖는 알고리즘 중 가장 빠를까요?

삽입 정렬은 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 따라서 삽입할 위치까지만 탐색하면 되기 때문에 선택 정렬과 버블 정렬에 비해 빠릅니다.

# 05. 참고자료

[[정렬 알고리즘] 01 삽입 정렬(Insertion Sort)이론 및 구현](https://rninche01.tistory.com/entry/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-01-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC)

[자바 [JAVA] - 삽입 정렬 (Insertion Sort)](https://st-lab.tistory.com/179)
