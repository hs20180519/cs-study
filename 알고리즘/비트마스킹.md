### **00. 비트마스킹이란?**

비트마스킹은 **비트(bit)**를 활용하여 데이터를 저장하거나 조작하는 기법이다.  
정수를 이진법으로 표현한 뒤, **비트 연산**을 통해 특정 데이터를 효율적으로 처리할 수 있다.  
특히, 상태를 저장하거나 집합 연산을 수행할 때 사용된다.


### **01. 비트마스킹 장점**

#### 1. **메모리

- 비트마스킹은 하나의 정수(32비트 또는 64비트)에 **최대 32개 또는 64개의 상태**를 저장할 수 있다.
- 배열이나 다른 자료구조를 사용하는 경우보다 훨씬 **메모리 효율적**이다.
	- 크기가 32인 집합을 표현할 때, 정수형 변수 1개로 처리
	- boolean 배열은 32개 이상의 메모리를 사용

#### 2. **시간 복잡도 

- 비트 연산(AND, OR, XOR 등)은 하드웨어 수준에서 **고정된 시간**에 실행되므로 매우 빠르다.
	- 비트 연산은 CPU의 ALU(산술 논리 장치)가 처리하는 기본적인 연산이다.
	- 하드웨어가 이진수를 직접 다루기 때문에, 따로 복잡한 과정 없이 바로 결과를 반환
- 특정 원소의 삽입, 삭제, 조회 등 연산이 **O(1)**로 처리 가능하다.
- 대량의 데이터를 처리하거나 반복 연산 시 성능 차이가 크게 난다.


### **02. 비트 연산자

| 연산자     | 설명                       | 예시 입력          | 예시 결과  |
| ------- | ------------------------ | -------------- | ------ |
| `&` AND | 두 비트가 모두 1일 때만 1         | `1101 & 1011`  | `1001` |
| \|      | 하나라도 1이면 1               | `1101 \| 0000` | `1101` |
| `^` XOR | 두 비트가 서로 다르면 1           | `1101 ^ 1011`  | `0110` |
| `~` NOT | 비트를 반전 (1 → 0, 0 → 1)    | `~1101`        | `0010` |
| `<<`    | 비트를 왼쪽으로 이동, 오른쪽은 0으로 채움 | `0011 << 2`    | `1100` |
| `>>`    | 비트를 오른쪽으로 이동             | `1100 >> 2`    | `0011` |

### **03. 범위 처리**

1. **모든 비트 설정**
    
    - `set = (1 << N) - 1;`  
        (N개의 비트를 모두 1로 설정)
2. **비트 초기화**
    
    - `set = 0;`  
        (모든 비트를 0으로 초기화)
3. **특정 범위의 비트 조작**
    
    - 예) 2~4번 비트를 1로 설정
        
        ```java
		set |= ((1 << 4) - (1 << 2)); // 2 ~ 4 번 비트 설정

        ```

    
### **04. 기본 연산**

#### 1. **삽입**

특정 원소를 집합에 추가.

```java
int set = 0; // 빈 집합
set |= (1 << 3); // 3번 비트 추가
```

#### 2. **삭제**

특정 원소를 집합에서 제거.

```java
set &= ~(1 << 3); // 3번 비트 제거
```

#### 3. **조회**

특정 원소가 집합에 포함되어 있는지 확인.

```java
boolean contains = (set & (1 << 3)) != 0; // 3번 비트가 포함되어 있으면 true
```

#### 4. **토글**

특정 원소의 상태를 반전(0 → 1, 1 → 0).

```java
set ^= (1 << 3); // 3번 비트 반전
```


### **예제 코드 (JAVA)**


```java
public class BitMaskingExample {
    public static void main(String[] args) {
        int set = 0; // 빈 집합
        
        // 삽입: 2번, 4번 비트를 추가
        set |= (1 << 2);
        set |= (1 << 4);
        System.out.println("삽입 후: " + Integer.toBinaryString(set));
        
        // 조회: 2번 비트가 포함되어 있는지 확인
        boolean contains2 = (set & (1 << 2)) != 0;
        System.out.println("2 포함 여부: " + contains2);
        
        // 삭제: 4번 비트 제거
        set &= ~(1 << 4);
        System.out.println("삭제 후: " + Integer.toBinaryString(set));
        
        // 토글: 2번 비트 상태 반전
        set ^= (1 << 2);
        System.out.println("토글 후: " + Integer.toBinaryString(set));
    }
}
```

### 결과

```
삽입 후: 10100
2 포함 여부: true
삭제 후: 00100
토글 후: 00000
```


### 05. 면접에서 나올 수 있는 질문

#### **하드웨어 용량이 중요한 IoT 같은 분야에서 비트마스킹은 왜 효율적일까요?**

비트마스킹은 상태를 저장하거나 집합 연산을 수행할 때 메모리 사용량을 줄이고 연산 효율을 높일 수 있습니다. 
데이터를 비트 단위로 저장하여 불필요한 메모리 낭비를 줄일 수 있고, 연산 속도가 빨라 배터리 소모를 줄일 수 있습니다.
예를 들어 센서의 16가지 상태를 배열(16바이트) 대신 정수 하나(4바이트)로 표현할 수 있습니다. 
따라서 비트마스킹은 메모리와 배터리가 제한된 IoT 기기나 임베디드 시스템에서 효과적으로 사용될 수 있습니다. 
