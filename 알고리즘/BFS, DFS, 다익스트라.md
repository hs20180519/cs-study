# 01. DFS(깊이 우선 탐색), BFS(너비 우선 탐색)

## 개념

그래프 탐색 알고리즘

가능한 모든 경로를 찾는 문제(Brute force)라면 DFS, BFS 모두 사용이 가능하지만 

일반적으로 현재 상태를 저장할 때는 DFS를, 최단경로를 찾기 위해서는 BFS 를 사용한다.

![image.png](https://velog.velcdn.com/images/sour_grape/post/e62fdba3-6a18-4534-be63-bd1f36e2ffb2/image.png)

## DFS(Depth First Search, 깊이 우선 탐색)

- 시작 노드에서, **방문할 수 있는 가장 깊은 노드를 먼저 방문**하는 그래프 탐색 알고리즘
- 재귀나 스택을 이용해서 구현
- 순열, 조건, 부분집합
- 경우의 수 탐색

DFS 의 경우 보통 재귀를 이용해서 많이 구현하는데, 현재 상태를 매개변수로 넘기기 쉽고 코드가 간결하기 때문이다.

재귀로 구현하는 경우, **스택 오버 플로우**와 **종결 조건**에 유의하여야 한다. 

깊이 우선 탐색 이라는 특성 상 여러 가지 경우의 수를 끝(리프 노드)까지 탐색해서 확인해봐야 하는 경우에 DFS를 많이 사용한다. 예를 들면 N-Queen 

**백준 9963 - N Queen**

[백준 9963](https://www.acmicpc.net/problem/9663)

모든 경우의 수를 확인해야 하니, 단순 DFS로 풀다 보면 시간초과나 스택 오버 플로우가 발생하게 되는데 그런 경우에는 백트래킹이나 DP를 이용한다.

개인적으로 백트래킹이나, 재귀로 구현하는 DP 문제들이 DFS에 일종의 방문처리를 한 거라고 생각한다. 이미 같거나 나은 상태로 방문했으니 더 이상 구할 필요가 없다는 식

**백준 - N과 M 시리즈**

[N과 M](https://www.acmicpc.net/workbook/view/2052)
기본 순조부 

**백준 1937 - 욕심쟁이 판다**

[백준 1937](https://www.acmicpc.net/problem/1937)

전형적인 DFS 문제에 시간 제한을 두어 DP로 풀어아하는 문제

---

## BFS(**Breadth** First Search, 너비 우선 탐색)

- 시작 노드에서 인접한 노드를 먼저 방문하는 그래프 탐색 알고리즘
- 큐를 이용해서 구현
- **최단 경로, 연쇄 작용 문제, 덩어리 구하기**

모든 경우의 수를 확인할 수 있다는 점은 DFS와 같지만, BFS는 **가중치가 없는 모든 노드에 대해 최단경로를 보장**한다.

따라서 최단 거리를 찾아야 하는 문제에서는 DFS보다 빠른 성능을 기대할 수 있다. 조건을 만족하는 노드를 발견한다면 처음 발견한 상태가 반드시 최단경로중 하나이기 때문

- DFS 로 문제를 풀 때 종결 처리를 제대로 해줬음에도 시간초과가 나거나 스택오버플로우가 발생한다면 BFS로 풀 수 있는지 확인해보자.

큐에 방문처리를 하는 것 역시, 단순히 사이클을 방지하는 것뿐만 아니라 최단경로로 이미 탐색한 경우를 확인할 필요가 없는 것. 

DFS에서 종결 조건이 가장 중요하다면, BFS에서는 **방문 처리가 핵심**이다.

**문제에 따라 물리적으로 같은 위치(x, y)이더라도 방문하는 상태(벽을 부순다, 열쇠가 있다 등)에 따라 방문 처리를 별도로 분리**해주는 문제가 많다.

---

**백준 7576 - 토마토**

[백준 7576](https://www.acmicpc.net/problem/7576)

**백준 3055 - 탈출**

[백준 3055](https://www.acmicpc.net/problem/3055)

의외로 많이들 간과하는 포인트 중 하나가

BFS 역시 depth 를 저장하며 탐색이 가능하다는 점이다.

```java
private static int goSafe() {
		Deque<int[]> go = new ArrayDeque<>();
		
		go.add(new int[] {goR, goC});
		
		int time = 0;
		while(!go.isEmpty()) {//고슴도치가 갈곳 없을때까지
			int size = water.size();//물이 시간순으로 참
			
			for(int s = 0 ; s < size ; s++) {
				int[] cur = water.poll();
				int cr = cur[0], cc = cur[1];
				
				for(int d=0 ; d < 4 ; d++) {
					int nr = cr + dr[d];
					int nc = cc + dc[d];
					
					if(isIn(nr,nc) && !visit[nr][nc] && map[nr][nc] == '.') {
						visit[nr][nc] = true;//물이 찰 예정
						water.add(new int[] {nr,nc});
					}
				}
			}
			
			//고슴도치 이동
			size = go.size();
			
			for(int s = 0 ; s < size ; s++) {
				int[] cur = go.poll();
				int cr = cur[0], cc = cur[1];
				if(cr == safeR && cc == safeC) return time;
				
				for(int d=0 ; d < 4 ; d++) {
					int nr = cr + dr[d];
					int nc = cc + dc[d];
					
					if(isIn(nr,nc) && !visit[nr][nc]) {
						if(map[nr][nc] == '.' || map[nr][nc] == 'D')
							go.add(new int[] {nr,nc});
							visit[nr][nc] = true;

					}
				}
			}
			
			time++;
			
		}//end q while
		
		return -1;
	}
```

depth를 저장하며 탐색하면 추가적인 자료구조(`int distance[][]`)를 사용하지 않아도 되는 경우가 종종 있기 때문에 익숙해지면 좋다.

### 덩어리 구하는 류의 문제

**백준 2636 - 치즈**

[백준 2636](https://www.acmicpc.net/problem/2636)

**프로그래머스 25013 - 석유 시추**

[프로그래머스 25013](https://school.programmers.co.kr/learn/courses/30/lessons/250136)


### 그 외 방문처리가 핵심이었던 문제들

**백준 - 벽 부수고 이동하기 시리즈**

[벽 부수고 이동하기](https://www.acmicpc.net/workbook/view/6517)

일반적인 BFS 문제에서, 벽을 부순다 라는 조건이 추가된 문제

단순하게 노드에 방문처리를 하는 것이 아니라, 노드에 같은 상태로 방문했는지를 확인해야 한다.

혹은, 노드를 이차원 배열의 좌표로 생각하는 것이 아니라, 이차원 배열 + 벽을 부순 개수(상태) = 3차원 배열이 BFS의 노드라고 생각해도 좋다. 


**프로그래머스 150365 - 미로 탈출 명령어**

[프로그래머스 150365](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

BFS + 우선순위 큐를 활용해야 했던 문제

방문해온 문자열을 저장해야 하기 때문에, 단순히 방문처리를 이차원 배열로 하는 것이 아니라 몇번째에 방문했는지(depth) 3차원 방문 체크로 확인해야 했던 문제이다.
    


모두 주의할 점은, 가중치가 있는 그래프라면 **다익스트라**를 이용해야 한다는 점이다.



# 02. 다익스트라 알고리즘(Dijkstra Algorithm)

### 개념

다익스트라 알고리즘은 **가중치가 있는 그래프에서 하나의 정점에서 모든 다른 정점까지의 최단 경로를 구하는 알고리즘**이다.

**우선순위 큐(Priority Queue)** 를 활용하여 구현하며, BFS와 비슷한 흐름을 가지지만 가중치를 기준으로 최단 경로를 우선적으로 탐색한다.

### **특징**

1. **가중치가 양수일 때만 사용 가능**: 다익스트라 알고리즘은 음의 가중치가 존재하는 경우 제대로 동작하지 않는다.
2. **최단 경로 탐색**: 단일 출발지에서 특정 노드까지의 최단 경로를 계산한다.
  
    
    
### **과정**

1. **거리 배열 초기화**: 출발 노드의 거리는 0으로, 다른 노드의 거리는 무한대(∞)로 설정한다.
2. **우선순위 큐 초기화**: 출발 노드를 큐에 삽입한다.
3. **큐에서 노드 꺼내기**: 큐에서 가장 거리가 짧은 노드를 꺼내고, 해당 노드와 연결된 다른 노드의 최단 경로를 갱신한다.
4. **거리 갱신**:
    - 현재 노드를 거쳐 다른 노드로 이동하는 비용이 기존 비용보다 작으면 갱신한다.
    - 갱신된 노드를 다시 큐에 삽입한다.
5. **반복 종료**: 큐가 빌 때까지 3~4번 과정을 반복한다.


### **예제 코드 (Java)**

```java
public static void dijkstra(int start) {
		PriorityQueue<int[]> pq = new PriorityQueue<>((o1,o2) -> {
			return o1[1] - o2[1];//가중치기준 정렬
		});
		
		boolean[] visit = new boolean[V+1];
		pq.add(new int[] {start,0});
		distance[start] = 0;
		
		while(!pq.isEmpty()) {
			int[] curNode = pq.poll();
			int cNode = curNode[0];
			
			if(visit[cNode]) continue;
			visit[cNode] = true;
			
			for(int[] node : edge[cNode]) {
				int to = node[0];
				int toWeight = node[1];
				if (distance[to] > distance[cNode] + toWeight) {
				    distance[to] = distance[cNode] + toWeight;
				    pq.add(new int[] {to, distance[to]});
				}
			}
			
		}
	}
```


**백준 1261 - 알고스팟**

[백준 1261](https://www.acmicpc.net/problem/1261)

언뜻 보면 전형적인 BFS 문제같지만, 다익스트라로 풀어야 하는 이유는 (1) **벽을 부수는** (2) **최소 수**를 구해야하기 때문이다

기존의 미로 탐색은 상하좌우로 이동할 때의 가중치가 1이지만, 벽을 부수는 것에 대한 가중치가 존재하기 때문에 다익스트라로 풀어야 한다.

벽부수고 이동하기 같은 경우에는 목적지까지의 최단 경로를 찾기 때문에 벽을 부수는 행위가 가중치로 작용하는 것이 아니라 해당 노드에 방문하는 상태를 의미한다. 그래서 다차원 방문 배열을 사용하는 것.

반면 알고스팟의 경우, 경로를 다소 돌아가더라도 **가중치가 0인 노드와 1인 노드를 방문하는 문제**이기 때문에 다익스트라가 적합하다.



### **다익스트라와 BFS의 차이점**

| **특징** | **BFS** | **다익스트라** | **벨만 포드** |
| --- | --- | --- | --- |
| **가중치** | 모든 간선의 가중치가 동일해야 함 | 가중치가 양수인 경우에 적합 | 가중치에 음수 포함 |
| **탐색 방식** | 모든 경로를 동일한 가중치로 탐색 | 낮은 가중치부터 탐색 |  |
| **사용 데이터 구조** | 큐 (Queue) | 우선순위 큐 (Priority Queue) |  |
| **사용 사례** | 최단 경로 탐색(가중치가 없는 경우) | 최단 경로 탐색(가중치가 있는 경우) |  |


# 03. 유형 정리

**문제에 적합한 탐색 알고리즘 선택하기**

1. **DFS (깊이 우선 탐색)**
    - 경우의 수를 끝까지 탐색해야 하는 문제
    - 백트래킹이나 순열/조합과 관련된 문제
    - 그래프의 깊은 부분까지 탐색해야 하는 경우 (예: N-Queen, 부분집합 문제)
2. **BFS (너비 우선 탐색)**
    - 최단 경로를 찾는 문제
    - 동시다발적으로 퍼져가는 문제 (예: 불확산, 덩어리 탐색)
    - 가중치가 없는 그래프에서 효율적
    - 예: 토마토 익히기, 미로 탐색
3. **다익스트라 (Dijkstra)**
    - 가중치가 있는 그래프의 최단 경로 문제
    - 모든 가중치가 양수일 때 사용 가능
    - 최단 경로를 효율적으로 계산해야 하는 문제
    - 예: 특정 출발지에서 목적지까지의 최소 비용 경로 탐색
4. **벨만-포드 (Bellman-Ford)**
    - 음수 가중치가 있는 그래프에서 최단 경로 문제
    - 음수 사이클의 존재 여부 확인 가능
    - 시간복잡도가 크므로 데이터가 작을 때 적합
5. **플로이드-워셜 (Floyd-Warshall)**
    - 모든 노드 간의 최단 경로를 찾는 문제
    - 인접 행렬 기반으로 동작하며, O(V³) 시간 복잡도
    - 예: 도시 간 경로 탐색, 네트워크 비용 계산
    

**문제를 풀 때 고려할 것**

1. 그래프의 특성 (가중치, 방향성, 음수 간선 여부)
2. 탐색 목표 (최단 경로, 모든 경로 탐색, 연결성 확인 등)



# 04. 면접에 자주 나오는 질문

### 1. **BFS(너비 우선 탐색)에 대해 설명해 주세요.**

- **답변:**
BFS는 **그래프 탐색 알고리즘** 중 하나로, '너비 우선'으로 노드를 탐색합니다. 즉, 시작 노드에서 인접한 노드를 먼저 모두 탐색하고, 그 다음 단계에서 아직 방문하지 않은 노드를 탐색하는 방식입니다. 큐(Queue)를 사용하여 구현되며, FIFO(선입선출) 방식으로 동작합니다.
- BFS는 최단 경로를 찾는 데 유용하고, 연결 요소를 탐색할 때 효율적입니다.
- **시간 복잡도는** O(V + E) (V: 정점의 수, E: 간선의 수)입니다.
    
    

### 2. **DFS와 BFS의 차이점은 무엇인가요?**

- DFS와 BFS는 모두 그래프 탐색 알고리즘이지만, 탐색 방식이 다릅니다.
- **DFS(깊이 우선 탐색)**은 가능한 한 깊게 탐색한 후, 더 이상 갈 수 없으면 되돌아가서 다른 경로를 탐색하는 방식입니다. 스택(Stack)을 사용하거나 재귀 호출을 통해 구현할 수 있습니다.
- **BFS(너비 우선 탐색)**은 시작 노드에서부터 인접한 노드를 차례대로 탐색하며, 각 노드에 대해 최단 경로를 보장하는 특성이 있습니다. 큐(Queue)를 사용하여 구현됩니다.


### 3. **다익스트라 알고리즘에 대해 설명해 주세요.**

- 다익스트라는 **가중치가 있는 그래프에서 최단 경로를 구하는 알고리즘**입니다.
- 아직 방문하지 않은 노드 중 가장 거리가 짧은 노드를 선택하고, 선택된 노드를 기준으로 인접한 노드들의 거리를 갱신하는 방식으로 동작합니다.
- **시작 노드**에서 **다른 모든 노드로 가는 최단 경로**를 구하며, **그리디 알고리즘**을 기반으로 합니다.
- 우선순위 큐를 사용해 구현하며, 시간 복잡도는 **O((V + E) log V)**입니다.
    

### 4. **다익스트라 알고리즘의 한계점은 무엇인가요?**

- 다익스트라 알고리즘은 음의 가중치를 가진 간선이 존재할 경우 제대로 동작하지 않습니다. 따라서 음의 가중치를 처리하려면 **벨만-포드 알고리즘**을 사용해야 합니다.
- 또한, 다익스트라는 **단일 출발점**에서 다른 모든 노드로 가는 최단 경로를 구하는 알고리즘으로, 모든 경로를 계산하는 데 시간이 소요될 수 있습니다. 따라서 경우에 따라  **플로이드-워셜 알고리즘** 같은 다른 알고리즘이 더 효율적일 수 있습니다.
