## 1. 계수 정렬(Counting Sort)

- **데이터의 크기를 기준으로 개수를 세는 방식**으로 동작하는 정렬 알고리즘 중 하나이다.
- 주어진 데이터의 값 범위에 따라 개수를 저장할 수 있는 별도의 배열(카운트 배열)을 생성한 뒤, 데이터를 정렬한다.
- 데이터의 비교 없이, 각 데이터가 몇 번 등장했는지를 계산하여 순서를 결정하므로 **비교 기반 정렬 알고리즘**이 아니다.



## 2. 계수 정렬 과정

<img src="https://github.com/user-attachments/assets/2c08d21b-1dcf-4454-bcbb-197bcbd77e73" width="80%">


### 예제

원본 데이터: `[1, 4, 1, 2, 7, 5, 2]`


### 1단계: 카운트 배열 생성 (각 값의 빈도 계산)

- 데이터의 최소값: 1
- 데이터의 최대값: 7
- 값 범위: 7

```
원본 데이터: [1, 4, 1, 2, 7, 5, 2]
카운트 배열 초기 상태: [0, 0, 0, 0, 0, 0, 0] (값 범위: 1~7)
카운트 배열 업데이트:
1 → [1, 0, 0, 0, 0, 0, 0]
4 → [1, 0, 0, 1, 0, 0, 0]
1 → [2, 0, 0, 1, 0, 0, 0]
2 → [2, 1, 0, 1, 0, 0, 0]
7 → [2, 1, 0, 1, 0, 0, 1]
5 → [2, 1, 0, 1, 1, 0, 1]
2 → [2, 2, 0, 1, 1, 0, 1]

카운트 배열 최종 상태: [2, 2, 0, 1, 1, 0, 1]
```


### 2단계: 누적합 배열 생성 (데이터 위치 계산)

카운트 배열을 기반으로 누적합 배열을 생성

```
카운트 배열: [2, 2, 0, 1, 1, 0, 1]

누적합 배열 초기 상태: [2, 0, 0, 0, 0, 0, 0]
누적합 업데이트:
- 2번째 위치: [2, 4, 0, 0, 0, 0, 0]
- 3번째 위치: [2, 4, 4, 0, 0, 0, 0]
- 4번째 위치: [2, 4, 4, 5, 0, 0, 0]
- 5번째 위치: [2, 4, 4, 5, 6, 0, 0]
- 6번째 위치: [2, 4, 4, 5, 6, 6, 0]
- 7번째 위치: [2, 4, 4, 5, 6, 6, 7]

누적합 배열 최종 상태: [2, 4, 4, 5, 6, 6, 7]

```


### 3단계: 출력 배열 생성 (데이터 정렬)

(1) 원본 데이터를 역순으로 탐색

(2) 누적합 배열을 참고해 출력 배열에 데이터 배치

(3) 데이터가 배치될 때마다 **누적합 값을 감소**

```
원본 데이터: [1, 4, 1, 2, 7, 5, 2]
누적합 배열: [2, 4, 4, 5, 6, 6, 7]
출력 배열 초기 상태: [0, 0, 0, 0, 0, 0, 0]

배치 과정:
- 데이터 2 
출력 배열: [0, 0, 0, 2, 0, 0, 0]
누적합: [2, 3, 4, 5, 6, 6, 7]

- 데이터 5 
출력 배열: [0, 0, 0, 2, 0, 5, 0]
누적합: [2, 3, 4, 5, 5, 6, 7]

- 데이터 7 
출력 배열: [0, 0, 0, 2, 0, 5, 7]
누적합: [2, 3, 4, 5, 5, 6, 6]

- 데이터 2 
출력 배열: [0, 0, 2, 2, 0, 5, 7] 
누적합: [2, 2, 4, 5, 5, 6, 6]

- 데이터 1 
출력 배열: [0, 1, 2, 2, 0, 5, 7]
누적합: [1, 2, 4, 5, 5, 6, 6]

- 데이터 4 
출력 배열: [0, 1, 2, 2, 4, 5, 7]
누적합: [1, 2, 4, 4, 5, 6, 6]

- 데이터 1 
출력 배열: [1, 1, 2, 2, 4, 5, 7]
누적합: [0, 2, 4, 4, 5, 6, 6]

출력 배열 최종 상태: [1, 1, 2, 2, 4, 5, 7]

```

### 결과

- **원본 데이터:** `[1, 4, 1, 2, 7, 5, 2]`
- **카운트 배열:** `[2, 2, 0, 1, 1, 0, 1]`
- **누적합 배열:** `[2, 4, 4, 5, 6, 6, 7]`
- **출력 배열:** `[1, 1, 2, 2, 4, 5, 7]`

## 3. 계수 정렬 구현

```java
import java.util.Arrays;

public class CountingSort {

    public static void countingSort(int[] arr) {
        // 배열의 최소값과 최대값 계산
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;

        // 카운트 배열과 결과 배열 생성
        int[] count = new int[range];
        int[] output = new int[arr.length];

        // 각 요소의 개수 카운트
        for (int num : arr) {
            count[num - min]++;
        }

        // 카운트 배열의 누적 합 계산
        for (int i = 1; i < count.length; i++) {
            count[i] += count[i - 1];
        }

        // 결과 배열에 정렬된 값 삽입
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }

        // 원래 배열에 정렬된 값 복사
        System.arraycopy(output, 0, arr, 0, arr.length);
    }

    public static void main(String[] args) {
        int[] data = {1, 4, 1, 2, 7, 5, 2};
        countingSort(data);
        System.out.println("정렬된 배열: " + Arrays.toString(data));
    }
}

```

## 4. 계수 정렬의 특징

### 장점

- **빠른 속도**: 시간 복잡도가 (O(n+k))로, (n)은 데이터 개수, (k)는 데이터 범위이다. (k)가 크지 않다면 매우 효율적이다.
- **비교 연산 없음**: 데이터의 크기를 기준으로 정렬하므로 비교 연산이 필요 없다.

### 단점

- **메모리 사용량이 많음**: 데이터 범위가 크면 큰 크기의 카운트 배열을 생성해야 하므로 메모리 사용량이 많아질 수 있다.
- **정수 데이터에 한정**: 정렬 대상이 정수나 정수로 표현 가능한 데이터(예: 점수)로 제한된다.
- **데이터 범위 제한**: 데이터의 최대값과 최소값 차이가 너무 크면 비효율적이다.


## 5. 시간 복잡도

| 케이스 | 시간 복잡도 |
| --- | --- |
| 최선, 평균, 최악 | (O(n+k)) |
- (n): 데이터 개수
- (k): 데이터의 값 범위

### 공간 복잡도

- 추가 배열이 필요하므로 공간 복잡도는 (O(n+k))이다.


## 6. 자주 나오는 질문

### 질문: 계수 정렬이 무엇인가요?

계수 정렬은 데이터를 비교하지 않고 각 데이터가 몇 번 등장했는지를 세어 정렬하는 알고리즘입니다. 데이터의 값 범위를 기준으로 카운트 배열을 만들어, 각 데이터의 개수를 누적하여 정렬된 위치를 결정합니다. 데이터가 정수이고 범위가 작을수록 효율적입니다.


### 질문: 계수 정렬의 장단점을 말씀해주세요

**장점:**

1. **빠른 정렬 속도**: 데이터의 개수가 많아도 범위가 작으면 \(O(n + k)\)의 시간 복잡도로 빠르게 정렬할 수 있습니다.
2. **비교 연산 불필요**: 다른 정렬 알고리즘과 달리 데이터 간의 비교를 수행하지 않습니다.

**단점:**

1. **메모리 사용량**: 데이터의 범위가 크면 카운트 배열에 많은 메모리가 필요합니다.
2. **정수 데이터로 제한**: 실수나 문자열 등 연속적이지 않은 데이터에는 적용하기 어렵습니다.
3. **데이터 범위가 클 경우 비효율적**: 최대값과 최소값 차이가 큰 경우 메모리 낭비가 심합니다.

### 질문: 계수 정렬은 언제 사용될까요?

계수 정렬은 데이터가 정수이고, 값의 범위가 제한적인 경우에 주로 사용됩니다. 예를 들어, 학생들의 시험 점수(0~100점)를 정렬하거나, 특정 범위의 작은 정수 데이터를 정렬할 때 효과적입니다. 하지만 범위가 크거나 실수 데이터가 포함된 경우에는 다른 정렬 알고리즘이 더 적합합니다.
