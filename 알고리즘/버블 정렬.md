

## 1. 버블 정렬(Bubble Sort)

- **서로 인접한 두 원소를 비교하고 교환**하여 정렬하는 가장 기본적인 정렬 알고리즘 중 하나이다. 
- 이 과정에서 가장 큰(혹은 작은) 값이 한 회전을 거칠 때마다 배열의 끝으로 이동하기 때문에 마치 거품(bubble)처럼 보인다 하여 버블 정렬이라는 이름이 붙었다.

---

## 2. 버블 정렬 과정 (오름차순 기준)


<img src="https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png">


- **1회전**: 배열의 첫 번째 원소부터 N번째 원소까지 이동하며 인접한 두 원소를 비교한다. 비교한 두 원소 중 큰 값을 뒤로 보내며 가장 큰 원소가 배열의 마지막 위치로 이동한다.
- **2회전**: 1회전이 끝난 후에는 두 번째로 큰 원소가 배열의 끝에서 두 번째 위치로 이동한다. 따라서 이번에는 첫 번째 원소부터 (N-1)번째 원소까지만 비교한다.
- **이후 N-1회전까지 반복**: 모든 원소가 제자리를 찾을 때까지 이러한 과정을 반복한다. N-1번째 회전까지 수행하면 정렬이 완료된다.

---

## 3. 버블 정렬 구현 (Java)

```java
public class Bubble_Sort {
 
    public static void bubble_sort(int[] a) {
        bubble_sort(a, a.length);
    }
    
    private static void bubble_sort(int[] a, int size) {
        // round는 배열 크기 - 1 만큼 진행됨 
        for (int i = 1; i < size; i++) {
            boolean swapped = false;
            
            // 각 라운드별 비교횟수는 배열 크기의 현재 라운드를 뺀 만큼 비교함
            for (int j = 0; j < size - i; j++) {
                // 현재 원소가 다음 원소보다 클 경우, 위치를 교환
                if (a[j] > a[j + 1]) {
                    swap(a, j, j + 1);
                    swapped = true;
                }
            }
            
            // 최적화, 만약 교환이 발생하지 않았으면 이미 정렬된 상태
            if (!swapped) break;
        }
    }
    
    private static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

## 4. 버블 정렬의 특징

### 장점

- **구현이 매우 쉽다**: 인접한 원소들만 비교하고 교환하기 때문에 알고리즘이 직관적이며 코드가 간단하다.

### 단점

- **교환 횟수가 많다**: **특정 요소가 최종 위치에 있더라도 비교와 교환** 을 계속하므로 불필요한 연산이 많다.
- **효율성이 낮다**: 시간 복잡도가 \(O(n^2)\)이기 때문에 데이터가 많을수록 성능이 급격히 떨어진다.
- **실무에서 잘 사용되지 않음**: 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 실무에서는 거의 사용되지 않으며, 퀵 정렬이나 병합 정렬 같은 더 효율적인 정렬 알고리즘이 선호된다.

---

## 5. 시간 복잡도

| 케이스     | 시간 복잡도 |
|------------|-------------|
| 최선의 경우 | \(O(n)\) (이미 정렬된 경우) |
| 평균의 경우 | \(O(n^2)\) |
| 최악의 경우 | \(O(n^2)\) (역순으로 정렬된 경우) |


### 비교 및 교환 횟수

- **비교 횟수**: 항상 일정하며, \(n-1\), \(n-2\), ..., \(2\), \(1\) 번 비교가 필요해 총 비교 횟수는 \(n(n-1)/2\)이 된다.
- **교환 횟수**: 최악의 경우 교환할 때마다 3번의 이동(SWAP 작업)이 필요해 \(3n(n-1)/2\)회 수행된다. 최선의 경우에는 교환이 발생하지 않는다.

---

## 6. 자주 나오는 질문

- **질문 1:** 버블 정렬이 무엇인가요?  
  **답변:** 인접한 두 원소를 비교하여 정렬하는 간단한 알고리즘으로, 각 회전에서 가장 큰 또는 작은 값이 배열 끝으로 밀려나는 방식입니다. 평균과 최악의 시간 복잡도가 \(O(n^2)\)이라 자료 크기가 작은 경우에만 유용합니다.

- **질문 2:** 버블 정렬의 시간 복잡도는 어떻게 되나요?  
  **답변:** 최악과 평균의 경우 \(O(n^2)\)입니다. 모든 원소를 두 개씩 비교하기 때문입니다. 최선의 경우 \(O(n)\)로, 배열이 이미 정렬된 상태면 빠르게 정렬을 종료할 수 있습니다.

- **질문 3:** 버블 정렬이 실무에서 잘 사용되지 않는 이유는 무엇인가요?  
  **답변:** 시간 복잡도가 \(O(n^2)\)로 비효율적이기 때문에, 실무에서는 일반적으로 퀵 정렬이나 병합 정렬처럼 더 효율적인 \(O(n \log n)\) 정렬 알고리즘이 선호됩니다.

- **질문 4:** 버블 정렬과 선택 정렬의 차이점은 무엇인가요?  
  **답변:** 버블 정렬은 인접한 원소를 교환하며 정렬하고, 선택 정렬은 가장 작은 원소를 찾아 앞쪽에 위치시킵니다. 두 알고리즘 모두 \(O(n^2)\)의 시간 복잡도를 가지지만, 선택 정렬은 교환 횟수가 적어 조금 더 효율적입니다.

---

## 참고

[Heee's Development Blog - 버블 정렬](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)


