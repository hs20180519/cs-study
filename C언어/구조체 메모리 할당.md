## 01. 구조체
### 구조체
- 구조체(struct)는 서로 다른 타입의 변수들을 하나의 단위로 묶을 수 있는 사용자 정의 자료형이다. 
- 관련된 데이터를 하나의 객체처럼 다루기 위해서 사용된다.

### 객체(Object) vs 구조체(Struct)
#### 구조체(Struct)
- 단순한 데이터 묶음(데이터 컨테이너)
- 주로 값(데이터)만 저장하고, 메서드(함수)는 포함하지 않는다
- C에서는 **절차적 프로그래밍(Procedural Programming)** 을 위해 사용된다

#### 객체(Object)
- 데이터(속성) + 기능(메서드)을 함께 포함한다
- 클래스(Class)로부터 생성된다
- 보통 **OOP(객체지향 프로그래밍)** 의 개념과 함께 사용된다
- 메모리에서 동적으로 할당될 수 있으며, 참조(reference) 타입이 될 수 있다

#### 구조체 예제

```c
#include <stdio.h>

struct Example {
    int a;
    char b;
    double c;
};

int main() {
    struct Example ex;
    printf("Size of struct Example: %lu\n", sizeof(ex));
    return 0;
}
```

### sizeof
`sizeof` 연산자는 데이터 타입이나 변수, 구조체 등의 크기를 바이트 단위로 반환한다.

#### 기본 데이터 타입 크기
```c
printf("Size of int: %lu\n", sizeof(int));      // 4바이트
printf("Size of char: %lu\n", sizeof(char));    // 1바이트
printf("Size of double: %lu\n", sizeof(double)); // 8바이트
```

## 02. 구조체 메모리 크기 계산법

### 규칙
- **각 멤버는 선언된 순서대로 메모리에 배치된다.**
- **각 멤버는 자신의 크기에 맞는 정렬 기준(Alignment)에 따라 배치된다.**
- **메모리 정렬(패딩, Padding)이 적용되어야 할 경우, 빈 공간이 삽입될 수 있다.**
- **구조체의 전체 크기는 가장 큰 멤버의 크기의 배수가 된다.**

### 주의해야할 점
- **내림차순 정렬(`double → int → char`)이 가장 최적화된 상태** (패딩 최소화).
- `#pragma pack(1)`을 사용하면 메모리 크기를 줄일 수 있지만 성능 저하가 일어날 수 있다.  
- 멤버 배치는 **메모리 정렬**과 **패딩**을 고려하여 결정해야 한다.
 
### 패딩(Padding)
- 패딩 : CPU의 메모리 접근 속도를 최적화하기 위해 구조체의 멤버들이 특정 바이트 경계에 맞춰 배치되도록 추가되는 빈 공간

### **`#pragma pack(1)`**
- 구조체의 메모리 정렬(Alignment)을 강제로 1바이트 단위로 맞춰, 패딩 없이 구조체의 크기를 최소화하는 지시문
- CPU의 메모리 접근 성능이 저하될 수 있다.
  - CPU는 메모리를 읽을 때 워드(32bit / 64bit) 단위로 읽기 때문
- 네트워크 프로토콜 패킷, 메모리를 아껴야 하는 임베디드 시스템 등에서 사용

###  **`alignas()`**

#### 패딩 예제
```c
struct Example {
    int a;    // 4바이트
    char b;   // 1바이트 + 3바이트 패딩 (4바이트 정렬)
    double c; // 8바이트 (8바이트 정렬)
};
```

### 메모리 배치:
```
| a (4B) | padding (0B) | b (1B) | padding (3B) | c (8B) |
```
- `int a`는 4바이트이므로 4바이트 정렬이 필요하다.
- `char b`는 1바이트지만, `double c`가 8바이트 정렬을 요구하므로 `char b` 이후 3바이트 패딩이 추가된다.
- `double c`는 8바이트 정렬을 맞추기 위해 8바이트 단위로 배치된다.

**총 크기: 16바이트**  
전체 크기는 `4 + 1 + 3 + 8 = 16바이트`가 된다.


#### `#pragma pack(1)`을 사용한 경우
```c
#pragma pack(1)
struct Example {
    int a;    // 4바이트
    char b;   // 1바이트
    double c; // 8바이트
};
#pragma pack()
```
### 메모리 배치:
```
| a (4B) | b (1B) | c (8B) |
```

**총 크기: 13바이트**  
패딩이 없지만 메모리 정렬이 깨져서 성능 저하 가능


#### `alignas()`을 사용한 경우

```
#include <stdalign.h>
struct Aligned {
    int a;
    char b;
    double c;
} alignas(16); // 전체 크기를 16바이트로 맞춤
```
**총 크기: 16바이트**  


## 03. 메모리 구조체 크기 계산해보기

### 기존 순서 (`int → char → double`)
```c
struct Example {
    int a;    // 4바이트
    char b;   // 1바이트 + 3바이트 패딩 (4바이트 정렬)
    double c; // 8바이트 (8바이트 정렬)
};
```
### 메모리 배치:
```
| a (4B) | padding (0B) | b (1B) | padding (3B) | c (8B) |
```
**총 크기: 16바이트**


## 2. 내림차순 정렬 (`double → int → char`)
```c
struct Example {
    double c; // 8바이트 (8바이트 정렬)
    int a;    // 4바이트
    char b;   // 1바이트 + 3바이트 패딩 (4바이트 정렬)
};
```
### 메모리 배치:
```
| c (8B) | a (4B) | b (1B) | padding (3B) |
```
**총 크기: 16바이트**  
(패딩 최소화)

---

## 3. 오름차순 정렬 (`char → int → double`)
```c
struct Example {
    char b;   // 1바이트 + 3바이트 패딩 (4바이트 정렬)
    int a;    // 4바이트
    double c; // 8바이트 (8바이트 정렬)
};
```
### 메모리 배치:
```
| b (1B) | padding (3B) | a (4B) | c (8B) |
```
**총 크기: 16바이트**  


## 4. 모든 멤버를 `char` 타입으로 배치 (`char → char → char`)
```c
struct Example {
    char a;  // 1바이트
    char b;  // 1바이트
    char c;  // 1바이트
};
```
### 메모리 배치:
```
| a (1B) | b (1B) | c (1B) |
```
**총 크기: 3바이트** (패딩 없음)


## 5. `#pragma pack(1)`을 사용한 경우
```c
#pragma pack(1)
struct Example {
    int a;    // 4바이트
    char b;   // 1바이트
    double c; // 8바이트
};
#pragma pack()
```
### 메모리 배치:
```
| a (4B) | b (1B) | c (8B) |
```
**총 크기: 13바이트**  
(패딩 없음, 하지만 메모리 정렬이 깨져서 성능 저하 가능)



## 04. 면접에서 나올 질문 / 답변

### Q1. 구조체의 크기가 예상보다 클 수 있는 이유는?
**A:** 구조체 내부의 멤버들은 CPU의 성능 최적화를 위해 정렬(alignment)되므로, 필요한 경우 패딩이 추가되기 때문이다.

### Q2. 구조체에서 패딩을 최소화하려면 어떻게 해야 하는가?
**A:** 구조체 멤버를 크기가 큰 순서대로 정렬하면 패딩이 최소화될 수 있다.

### Q3. `#pragma pack(1)`을 사용하면 어떤 효과가 있는가?
**A:** `#pragma pack(1)`을 사용하면 패딩 없이 모든 멤버가 1바이트 단위로 정렬된다. 하지만 메모리 접근 속도가 느려질 수 있다.


