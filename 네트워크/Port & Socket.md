# 01. 포트

전송 계층은 응용 계층과의 연결다리 역할을 하는데, 포트는 그 과정에서 사용되는 개념이다.

- 패킷 수신 시, 패킷이 수신지 호스트로 도착했다고 해서 수신이 끝난 것이 아님
    
    → 목적에 맞게 애플리케이션의 프로세스까지 전달되어야 한다.
    
- 패킷 전송 시에도, 수신지 호스트의 실행 중인 애플리케이션 프로세스까지 전달되어야 함

⇒ 패킷의 최종 수신 대상은 특정 애플리케이션 프로세스

- 포트: 패킷에 특정 애플리케이션을 식별할 수 있는 정보

## 포트의 분류

- 전송 계층에서는 **포트 번호**를 통해 특정 애플리케이션을 식별
- TCP와 UDP는 송신지 포트 번호와 수신지 포트 번호를 포함
- 16비트로 표현, $2^{16}$개의 포트 사용 가능
- 할당 가능한 포트 번호: 0 ~ 65535(65536개)
- 포트 번호는 번호의 범위에 따라 세 종류로 나뉜다: 잘 알려진 포트, 등록된 포트, 동적 포트

| 포트 종류 | 포트 번호 범위 |
| --- | --- |
| 잘 알려진 포트 | 0~1023 |
| 등록된 포트 | 1024~49151 |
| 동적 포트 | 49152~65535 |

### 잘 알려진 포트(well-known port, system port)

- 0 ~ 1023
- 범용적으로 사용되며 애플리케이션 프로토콜이 일반적으로 사용하는 포트번호

<img width="297" alt="image (1)" src="https://github.com/user-attachments/assets/ad0c8209-1cc4-4654-847e-236e8acaff49">

### 등록된 포트(registered port)

- 1024 ~ 49151

<img width="390" alt="image (7)" src="https://github.com/user-attachments/assets/2b78f047-12ae-457e-a9f8-f7f181f7c8a7">

### 동적 포트(dynamic port), 사설 포트(private port), 임시 포트(ephemeral port)

- 49152 ~ 65535
- 인터넷 할당 번호 관리 기관(IANA)에 의해 할당된 애플리케이션 프로토콜이 없음
    - 잘 알려진 포트와 등록된 포트는 IANA에 의해 할당되어 있음

- 서버로서 동작하는 프로그램은 잘 알려진 포트와 등록된 포트로 사전에 암묵적으로 정해진 경우가 많음
- 반면, 클라이언트로서 동작하는 프로그램은 동적 포트번호 중에서 임의의 번호가 할당되는 경우가 많음
- e.g. 웹 브라우저
    - 웹 브라우저를 통해 특정 웹 사이트에 접속하는 상황은,
    - 웹 브라우저 프로그램과 서버 프로그램이 서로 패킷을 주고받는 것과 같음
    - 웹 브라우저 프로그램 포트번호는 동적 포트 번호대 중에서 임의로 자동할당됨
    
    <img width="645" alt="image (3)" src="https://github.com/user-attachments/assets/06019b57-5a77-4991-8c43-2a7b3fdb8297">

    - IP 주소와 포트번호에 대한 정보가 주어지면, 특정 호스트에서 실행 중인 특정 애플리케이션 프로세스를 식별할 수 있다.
        
        → `IP 주소:포트번호` 형식으로 표기되는 경우가 많음
        

## 포트 포워딩

- 네트워크 내 특정 호스트에 IP와 포트번호를 미리 할당하고, 해당 IP주소:포트번호로써 해당 호스트에게 패킷을 전달하는 기능
- 외부에서 내부 네트워크에 있는 호스트에 접근할 때 사용됨
- 공유기나 방화벽에서 사용됨
- `공인 ip 주소:특정 포트` 로 들어오는 요청을, 내부 네트워크의 특정 `사설 ip 주소:포트번호` 로 전달할 수 있음
- 예를 들어,
    - 네트워크 내부의 여러 호스트가 공인 IP 주소를 공유하는 상황에서 네트워크 외부에서 내부로(원격 접속 등) 통신을 시작한다고 가정
    - 네트워크 내부에서는 각 호스트별로 사설 IP를 가지고 있기 때문에, 외부의 호스트 입장에서는 수신지 주소를 결정하기 어려울 수 있음
        
        → 그래서 포트포워딩을 사용한다.
        
<img width="574" alt="image (4)" src="https://github.com/user-attachments/assets/e3f584eb-1adc-4e1e-92eb-197d2cd8a2a9">


# 02. 소켓 통신

## 소켓이란?

- 전송 계층과 응용 계층(프로그램) 사이에서 인터페이스(데이터 통로) 역할
- 응용 계층에 속하는 프로세스들은 소켓을 통해 전송 계층으로 데이터를 전달
    
    → 프로세스가 네트워크를 이용해 데이터를 송수신하기 위해서는 반드시 소켓을 통함
    
- 구성 요소: 프로토콜(TCP/UDP), IP(로컬/원격), 포트(로컬/원격)

![image (5)](https://github.com/user-attachments/assets/00c1036d-552c-4d77-8563-750df7d9001f)

## 종류

### 스트림 소켓(연결 지향형)

- TCP 사용
- 송수신자의 연결을 보장 → 신뢰성 있는 데이터 송수신이 가능
- 데이터의 순서 보장
- 대량 데이터 전송에 적합
- 1:1 연결

### 데이터그램 소켓(비연결 지향형)

- UDP 사용
- 데이터의 순서와 신뢰성을 보장하기 어려움
- 연결지향형에 비해 빠름
- 1:1, 1:N 연결

## 소켓 통신 과정(스트림 소켓)

![image (6)](https://github.com/user-attachments/assets/c7286ee3-ff5f-47ba-99aa-b2bf6667fe18)

### 서버

- listen 소켓: listen() 상태(연결 요청을 듣고 있는 상태)의 소켓
- 서버의 각 프로세스는 기본적으로 하나의 listen 소켓이 있음

1. socket(): 소켓 생성
2. bind(): 소켓에 ip, 포트번호 설정
3. listen()
    - 클라이언트의 연결 요청에 수신 대기열을 만들어, 몇 개의 클라이언트를 대기시킬지 결정
    - 소켓을 listen 상태로 바꾸고, 연결 요청을 기다림
4. accept()
    - 클라이언트로부터 요청을 받으면 실행됨
    - listen 소켓을 복제하여 새로운 소켓을 생성하여 클라이언트와 연결
    - 클라이언트와의 3-way handshake가 완료되면 종료
5. recv()/send()
    - recv(): 상대 소켓에게서 buffer를 수신받아 데이터를 읽음
    - send(): 보내고자 하는 데이터를 buffer에 작성하여 소켓을 통해 상대 소켓으로 전송
6. close(): 4-way handshake로 연결 종료 후 소켓 삭제

### 클라이언트

1. socket(): 소켓 생성
2. connect()
    - 통신할 서버의 ip와 포트번호로 통신 시도
    - 서버와의 3-way handshake가 완료되면 종료
3. recv()/send(): 서버 측과 동일
4. close(): 4-way handshake로 연결 해제

## 소켓 통신 과정(데이터그램 소켓)

- 스트림 소켓 통신과정에서 accept() 과정만 빠지고 동일함

![image (7)](https://github.com/user-attachments/assets/d94b298f-4f8e-44dc-8dd0-d974c4bfa682)

## 특징

- server-client 구조
- 양방향 통신
- 클라이언트와 서버가 실시간으로 계속하여 데이터를 주고받아야 하는 경우에 유리: 실시간 스트리밍이나 채팅에 유용하게 쓰임
- 프로그래밍 언어나 운영체제에 종속적

# 03. 자주 나오는 질문

## 소켓이란?

소켓은 서버와 클라이언트 간의 양방향 통신을 지원하는 프로토콜입니다. HTTP 프로토콜의 단점 중 하나인 단방향 통신을 극복하기 위해 개발되었습니다. 소켓 통신은 실시간으로 계속해서 데이터를 주고받아야 하는 상황에 적합하며, 실시간 채팅이나 라이브 방송 등에서 활용됩니다.

## 스트림 소켓과 데이터그램 소켓의 차이는?

스트림 소켓은 TCP 방식을 사용합니다. 클라이언트와 서버의 연결을 보장하여 데이터를 안정적이고 순서대로 송수신할 수 있다는 장점이 있고, 연결을 확인하는 절차가 추가되어 비교적 느리다는 단점이 있습니다. 데이터그램 소켓은 UDP 방식을 사용하여 클라이언트와 서버의 연결을 확인하지 않습니다. 따라서 스트림 소켓에 비해 비교적 데이터 전송의 신뢰성이 떨어지지만, 그만큼 빠르게 전송할 수 있다는 장점이 있습니다.

# 참고자료

[[CS] 그림으로 알아보는 네트워크 - 소켓 프로그래밍과 Handshaking](https://velog.io/@emplam27/CS-그림으로-알아보는-네트워크-소켓-프로그래밍과-Handshaking#마치며)<br>
[[기본]소켓(SOCKET)통신 이란?](https://helloworld-88.tistory.com/215)
