# 01. Blocking I/O Model

> I/O 작업은 Kernel level에서만 수행할 수 있기 때문에, 프로세스나 스레드는 커널에게 I/O를 요청해야 한다.
이 때 컨텍스트 스위칭이 발생하며, 커널 레벨에서 I/O 작업을 마치고 데이터를 반환하게 되면 어플리케이션 단의 스레드에 걸린 Block이 풀린다.
> 

- 가장 기본적인 I/O 모델, Linux에서의 모든 소켓 통신은 기본 Blocking으로 동작한다.
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식

![image](https://github.com/user-attachments/assets/47030e64-9c59-4a3f-8433-9cda7d9a7623)

## 작업 흐름

1. 프로세스가 커널에게 read 작업 요청
2. 데이터가 입력될 때까지 대기
3. 데이터가 입력되면 커널 모드에서 유저 모드로 데이터 복사

## 특징

1. I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기
2. 애플리케이션에서 다른 작업을 수행하지 못하고 대기하므로 자원 낭비

# 02. Non-Blocking I/O Model

- 위의 blocking 방식의 비효율성을 극복하고자 도입된 방식
- I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식

![image 1](https://github.com/user-attachments/assets/382d4e97-ac64-4d80-8cce-b01a0fc1cdcf)


## 작업 흐름

1. 유저가 커널에게 read 작업 요청
2. 데이터 입력 여부 상관없이, 바로 결과 반환
    
    이 때 입력 데이터가 없으면 없다는 결과 메세지 (EWOULDBLOCK) 반환
    
3. 입력 데이터가 있을 때까지 1, 2번 반복
    
    2번에서 결과 메세지를 받으면 다른 작업 진행 가능
    
    (**제어권**을 넘겨주지 않았기 때문에 자기 작업을 할 수 있다)
    
4.  recvBuffer에 입력 데이터가 있다면 Buffer로부터 데이터를 복사하여 받아옴
    
    recvfrom 함수는 빠른 속도로 data를 복사한 후, 복사한 data의 길이와 함께 반환
    

## 특징

1. I/O의 진행시간과 관계가 없기 때문에 작업을 오랜 시간 중지하지 않고 작업 진행 가능
2. 반복적으로 시스템 호출이 발생하므로 자원 낭비

## Blocking/Non-blocking 특성의 차이

호출된 함수가 호출한 함수에게 **제어권을 리턴해주는 시점**의 차이

⇒ Blocking: 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가짐

⇒ Non-blocking: 함수 B가 할 일을 다 마치지않더라도 A에게 제어권을 바로 넘겨주고, A는 B를 기다리면서도 다른 일을 진행 가능함

그러면, 이 때 호출된 함수의 결과를 언제 받는지 어떻게 알 수 있는가?

→ sync, async 개념 등장

# 03. Sync동기 vs. Async비동기

Non-blocking 방식일 때 호출된 함수의 결과를 어떻게 확인하는가?

어떤 응답이 올 지 궁금할 때 접근 가능한 3가지 방법

1. 눈 앞에서 기다리기 blocking
2. 작업 완료되었는지 계속 물어보기 polling
3. 완료되면 말해줘 callback

⇒ 1, 2번 방식이 Sync에 해당

⇒ 3번 방식이 Async에 해당

⇒ 동기 vs. 비동기 : 처리해야 할 작업들을 어떻게 처리 할 것인가에 대한 관점

⇒ 블로킹 vs. 논블로킹 : 처리되어야 하는 작업이 전체적인 작업 흐름을 막느냐 안 막느냐에 대한 관점

⇒ Blocking ≠ Synchronous

⇒ Non-blocking ≠ Asynchronous

![image 2](https://github.com/user-attachments/assets/3c4fa056-f86f-4730-8419-84fc5c593ab5)

1. 동기 Sync
- A(호출한 함수)가 B(호출된 함수)를 기다리면서 B의 작업 상태를 계속 체크
- 현재 처리되고 있는 작업의 요청이 모두 완료하여 응답을 리턴한 후 다음 작업 처리
1. 비동기 Async
- B(호출된 함수)의 수행 상태를 B 혼자 직접 신경쓰며 처리(Callback)
- 비동기는 호출시 Callback을 전달하여 작업 완료 여부를  호출한 함수에게 전달

## 동기/비동기 차이

⇒ 호출된 함수(B)의 작업 상태를 호출한 함수(A)가 신경쓰는지, 호출된 함수(B) 스스로 신경쓰는지

# 04. 예시

### 1. 동기 + 블로킹

코드가 순서대로 실행되는 일반적인 방식

### 2. 동기 + 논블로킹

- B(호출된 함수)에서 작업을 완료하지 않았더라도 제어권을 바로 반납하여 다른 작업을 진행할 수 있도록 한다.

→ A(호출한 함수)는 계속해서 B(호출된 함수)의 작업이 끝났는지 확인

→ (작업이 미완료일 경우) B(호출된 함수) 미완료 회신

→ **그동안 다른 작업 수행 가능**

→ A(호출한 함수)가 B(호출된 함수**)**의 작업이 끝났는지 확인

→ (작업이 완료되었을 경우) B(호출된 함수) 결과값 return

### 3. 비동기 + 블로킹

- B(호출된 함수)는 함수의 수행 결과를 콜백함수를 통해 전달한다.
- B(호출된 함수)가 제어권을 계속 가지고 있어 B(호출된 함수)의 작업이 완료되기 전까지 다른 작업을 진행할 수 없다.

### 4. 비동기 + 논블로킹

ex. 자바스크립트의 대표적 비동기 함수 setTimeout()

```jsx
function foo() {
	console.log("Async");
}

setTimeout(foo, 1000); // 1초 뒤 foo 함수 실행
console.log("Non-Blocking");

// 출력 결과
// Non-Blocking
// Async
```

- 함수를 호출한 쪽에서 처리하지 않고, setTimeout() 실행 후 콜백함수 foo 를 통해 알아서 결과가 처리된다.
- 호출된 함수가 제어권을 바로 반납하여 기다리지 않고 바로 다음 코드 실행되었다.

### 추가 예시

- 동기: 전화로 물어봐서 즉답을 얻는다.
- 비동기: 이메일로 물어보고 메일 송신을 완료(return)했지만 답은 언제 올지 모른다.
- ( ): 전화를 했는데 상대방이 너무 바빠 전화를 받지 않는다. 전화를 받을 때까지 계속 대기한다.
- ( ): 전화를 했는데 안 받는다. 끊었다가 나중에 다시 전화한다. 계속 반복했다가 어느 순간에 받아서 답을 얻는다.

# 05. 질문 정리

### 만약 여러 대의 클라이언트가 접속하는 서버를 블로킹 방식으로 구현하는 경우에 대해 설명해주세요.

하나의 클라이언트에 대해 I/O 작업을 진행하면 메인 스레드가 진행하던 작업이 중단됩니다.

따라서 작업에 대한 영향을 미치지 않게 하기 위해 클라이언트 당 스레드를 제공해야 합니다.

접속자 수가 증가함에 따라 많은 스레드가 생성되고 CPU의 컨텍스트 스위칭 횟수도 증가하게 됩니다. 이 때 컨텍스트 스위칭 비용으로 인해 비효율적으로 동작할 수 있습니다.

### Blocking I/O 와 Non-Blocking I/O 의 차이에 대해 설명해주세요.

블로킹 I/O

- I/O 작업을 처리하는 동안 호출한 스레드가 작업이 끝날 때까지 대기하는 방식입니다.
- 따라서 여러 개의 I/O 작업이 발생할 때 블록되어 있는 동안 다른 작업을 수행할 수 없는 단점이 있습니다.

넌블로킹 I/O

- I/O 작업이 완료될 때까지 기다리지 않고, 호출한 스레드를 바로 반환하는 방식입니다.
- 이 방식은 I/O 작업이 완료되지 않았더라도 호출한 스레드는 다른 작업을 수행할 수 있습니다.
- 그러나, I/O 작업이 완료되지 않았으므로 호출한 스레드가 다시 I/O 작업을 체크하거나 콜백을 처리하는 등의 추가적인 작업이 필요합니다.
- 여러 개의 I/O 작업을 병렬로 처리할 수 있고, 대기 시간을 최소화할 수 있어서 대규모 시스템에서 성능 개선을 할 수 있습니다.
- 그러나, 블록킹 I/O에 비해 복잡하고 코드가 길어질 수 있으며, I/O 작업이 완료되지 않았을 때 추가적인 처리가 필요하므로 오버헤드가 발생할 수 있습니다.

### 넌블로킹된 I/O 작업을 호출 스레드에 가져오는 방법 두 가지

멀티플렉싱과 콜백 방법 두 가지가 존재합니다.

멀티플렉싱은 하나의 스레드가 I/O 작업을 모니터링하며 작업이 완료된 것을 감지하는 기술입니다. 주로 select, poll, epoll 등의 시스템 콜을 사용합니다.

콜백은 I/O 작업이 완료되면 호출될 함수를 등록하는 방식으로, 비동기적으로 작동하는 방식입니다. I/O 작업이 완료되면 시스템에서 콜백 함수를 호출하고, 해당 콜백 함수에서 작업 결과를 처리합니다.

---

### 참고

- [https://didu-story.tistory.com/307](https://didu-story.tistory.com/307)
- [https://siyoon210.tistory.com/147](https://siyoon210.tistory.com/147)
- [https://murphymoon.tistory.com/m/entry/동기-비동기-블로킹과-논블로킹-2x2-매트릭스-운영체제-면접질문9](https://murphymoon.tistory.com/m/entry/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-2x2-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B89)
- [https://kkoon9.tistory.com/531](https://kkoon9.tistory.com/531)

### 추가 예시

1. 동기 + 블로킹
2. 동기 + 논블로킹
