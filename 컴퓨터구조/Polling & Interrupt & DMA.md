# 00. CPU와 입출력 장치 간 데이터 처리 방식

- CPU가 어떤 작업을 수행하던 도중 외부에서 작업 요청이 들어온다면 어떻게 처리할까?
- 외부 작업 요청의 예시
    - 키보드/마우스 조작
    - 네트워크의 패킷 수신
    - 저장 장치 입력 완료
    - USB 장치 연결 알림

# 01. Polling

- CPU가 자신과 연결된 입출력 장치에서 무슨 일이 있는지 주기적으로 확인하는 방식

## 장점

- 각 장치들로부터 동시에 신호가 발생해도 CPU에서 중복되지 않음
    
    → CPU가 확인하기 전까지는 이벤트가 발생해도 CPU로 들어오지 못하기 때문
    
- interrupt handler가 필요 없음
- interrupt 방식보다 구현이 쉬움

## 단점

- 이벤트 도착 시간이 길 경우 CPU time을 낭비하게 됨
- 확인 주기가 짧을수록 응답속도가 높고, 길수록 실시간성(real-time)이 떨어짐
- 연결된 I/O 장치의 개수가 많을수록 CPU 성능 하락
    
    → 장치가 많아질수록 확인 시간이 늘어나고, 그만큼 CPU가 다른 작업을 할 수 있는 시간이 줄어듬
    

# 02. interrupt

- 각 입출력 장치들이 필요할 때마다 CPU에게 interrupt 신호를 전송하는 방식
- CPU는 필요할 때만 입출력 장치와 통신하고, 나머지 시간 동안은 다른 일을 할 수 있기 때문에 polling에 비해 성능이 증가함
- 하지만 너무 많은 interrupt가 발생하게 되면 CPU가 해야 할 일을 제대로 처리하지 못하여 오히려 효율이 떨어질 수 있음

## interrupt가 발생하면 어떻게 처리할까?

- 컴퓨터는 일반적으로 코드를 순차 처리하는데, 중간에 I/O 장치가 CPU를 사용해야 할 때 interrupt 신호를 전송

### CPU가 interrupt 신호를 받았을 때의 동작 단계

1. 현재 CPU의 각종 레지스터와 상태를 스택에 저장
2. interrupt 핸들링을 위해 ISR(Interrupt Service Routine)을 수행
    - ISR: interrupt 종류에 따라 처리하는 방식을 미리 정의한 프로그램
3. 원래 수행하던 프로그램으로 돌아가 정상 동작
    - 1. 에서 저장한 CPU의 정보를 다시 불러들이고, 원래 수행하던 프로그램으로 동작
    - CPU 입장에서는 자신이 interrupt를 처리했는지 의식하지 못함

![image (1)](https://github.com/user-attachments/assets/fea7122c-143d-4cb7-8239-f91d39ee47bb)

# 03. DMA(Direct Memory Access)

- polling와 interrupt 모두 데이터의 이동과 처리를 CPU가 주관
- 즉, 데이터가
    - 입출력 장치 → CPU → 메모리
    - 메모리 → CPU
- 로 이동하는 과정에서 CPU가 자원을 소비한다
- 이 문제를 해결하고자, **CPU의 개입 없이** 입출력 장치가 메모리에 직접 접근(DMA)하여 데이터를 전송

- DMA는 CPU의 개입 없이 메모리와 하드웨어 장치 간 데이터 전송을 위해 만들어진 별도의 공간
- DMAC(DMA Controller): Bus의 주도권을 잡고 DMA를 가능하게 하는 주체

- CPU에 여러 입출력 장치가 연결되어 있었던 기존과 달리,
- DMA에 입출력 장치들이 연결되고 CPU는 DMA 장치가 연결됨

## 동작과정

1. CPU는 전송할 자료와 장소에 대한 위치를 나타내는 포인터와 전송 바이트 크기를 DMA에 전송
2. DMA는 해당 정보를 바탕으로 **CPU를 대신하여 I/O 장치와 메모리 간의 데이터 전송을 수행**
3. CPU는 그 사이에 다른 작업 처리
4. DMA가 작업을 마치면 CPU에 interrupt를 발생시킴으로써 작업의 완료를 알림
5. CPU는 이를 기반으로 데이터 처리 작업 수행

![image](https://github.com/user-attachments/assets/8d2bae5a-ffea-444e-a54d-787f998ab01c)

## 장점

- CPU의 역할이 현저히 줄어듬
- 프로그램 수행 중 interrupt의 발생 횟수 줄어듬
- CPU 가용 시간 up
- 시스템 효율성 up
- 입출력 성능 향상
- 대량의 데이터를 이동하거나 빠른 입출력을 요구하는 작업에서 유용

## DMA 전송 모드

- DMA가 메모리에 접근 및 전송하기 위해서는 bus를 사용해야 하는데, bus의 사용권한은 CPU가 관장
- CPU가 얼마나 오래 blocked 상태에 머무는지에 따라 DMA 전송 모드가 달라짐

### 1. Burst Mode

- 한 번에 큰 데이터 블록를 전송한 뒤, CPU가 버스 사용 권한을 되찾는 모드
- DMA가 버스를 독점하여 데이터를 빠르게 전송함
- 가장 빠른 전송 방식
- 데이터 블록을 한 번에 처리하므로, 전송 시간이 크게 단축됨

**장단점**

- 전송 속도가 가장 빠름
- DMA가 버스를 점유하는 동안 CPU은 완전히 blocked 상태
- CPU는 DMA 전송이 끝날 때까지 다른 작업을 수행할 수 없음

### 2. Cycle Stealing Mode

- 한 번에 word 단위로 데이터를 전송

- 입출력 장치가 데이터를 준비하는 동안 CPU가 버스를 사용하고,
- 데이터가 준비되면 DMA가 1 메모리 사이클 동안 버스 사용 권한을 받아 데이터를 전송
    - 메모리 사이클: 메모리와 데이터를 교환할 때 걸리는 기본 단위 시간
- 이후 CPU가 다시 버스 사용 권한을 가져옴

- CPU와 DMA가 동시에 bus를 사용하고자 하면, DMAC에게 우선권이 있음
    
    → CPU의 작업 속도가 DMAC보다 빠르기 때문쵸
    

- burst mode보다 전송 속도 느림
- DMA는 한 번에 1 메모리 사이클 동안만 버스를 점유하기 때문에 그 외의 시간에는 CPU가 버스를 사용할 수 있음
    
    → CPU의 작업이 완전히 중단되지 않음
    

**장단점**

- CPU가 blocked되어 있는 시간이 짧음
- 효율적으로 CPU와 DMA가 버스를 공유
- DMA 전송 속도가 burst mode보다 느림

### 3. Interleaving Mode

- CPU가 버스를 사용하고 있지 않을 때만 DMA가 버스 사용 권한을 가짐
- CPU 작업이 DMA의 작업보다 우선

**장단점**

- DMA가 CPU의 작업을 방해하지 않아 CPU의 작업이 중단되지 않음
- DMA가 버스를 사용할 기회가 적기 때문에 전송 속도가 가장 느림

# 04. 자주 나오는 질문

## 폴링과 인터럽트에 대해 설명해 주세요.

폴링은 CPU가 입출력장치를 주기적으로 감시하여 이벤트의 발생 여부를 확인하는 방식이고, 인터럽트는 이벤트가 발생한 경우 해당 장치가 CPU에게 직접 알리는 방식입니다.

## 직접 메모리 접근이 무엇이고, 왜 사용하나요?

입출력 장치가 CPU의 개입 없이 바로 메모리로 데이터를 전송할 수 있도록 하는 방식입니다. 만약 CPU를 통해서만 메모리에 접근해야 한다면, 데이터를 전송할 때마다 interrupt 신호를 보내야 하는데, 이는 빈도가 잦을수록 CPU에 부하를 증가시키고  오버헤드로 이어질 수 있습니다.

DMA를 사용하면 DMA 컨트롤러가 버스를 사용해 메모리와 입출력 장치 간 데이터를 전송하여 interrupt의 발생 횟수를 최소화합니다. CPU는 그 동안 다른 작업을 수행할 수 있으므로 시스템 전체의 효율을 향상시킬 수 있습니다.

## cycle stealing이 무엇인가요?

CPU와 DMA가 동시에 메모리에 접근할 때, CPU의 작업속도가 DMA보다 빠르기 때문에 DMA가 버스를 점유하는 우선권을 가지게 되는데, 이를 cycle stealing이라고 합니다.

# 05. 참고자료

https://review-answer.tistory.com/6

https://complicated0idea.tistory.com/14

https://www.geeksforgeeks.org/modes-of-dma-transfer/
