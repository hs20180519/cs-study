## 00. 브라우저

브라우저란 WWW 기반의 웹 서버에 접속해서 데이터를 전달 받아 화면에 보여주는 응용프로그램을 말한다.

오늘날 대표적인 브라우저로는 Crome, Internet Explore, FireFox 등이 있다.

## 01. 브라우저에 URL을 입력하면 일어나는 과정

<img src="https://velog.velcdn.com/images/wlwl99/post/5372bc91-ab77-4f0b-b416-08bd08f04231/image.png">

1. 사용자가 URL을 입력하면, 브라우저는 URL을 해독한다. 

2. 웹 브라우저가 URL로부터 프로토콜, 도메인 주소, 파일 경로, 포트 번호 등을 해독하면

3. OS 단에서 URL에 해당하는 서버로 데이터를 “**요청**”한다.

4. 이에 웹 서버는 웹 브라우저의 요청에 “**응답**”하고, 웹페이지가 사용자에게 나타난다.

## 02. 브라우저의 기본 구조

<img src="https://d2.naver.com/content/images/2015/07/59361-1.PNG">

*브라우저마다 차이 존재

### **사용자 인터페이스**
- 일반 사용자가 접근할 수 있는 영역이다. 
- URI를 입력할 수 있는 주소 표시줄, 이전/다음 버튼, 북마크 메뉴, 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼 , 홈 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이 사용자 인터페이스에 속한다. 

### **브라우저 엔진**
- 사용자 인터페이스와 렌더링 엔진 사이 동작을 제어한다

### **렌더링 엔진**
- 웹 서버로부터 응답 받은 자원을 웹 브라우저 상에 나타낸다. 
- 브라우저는 서버로부터 HTML 문서를 응답 받으면 렌더링 엔진의 **HTML 파서**와 **CSS 파서**에 의해 **파싱(parsing)**되어 **DOM, CSSOM 트리**로 변환되고 **렌더 트리**로 결합한다. 
- 이 렌더 트리를 기반으로 브라우저는 웹 페이지를 띄운다. 

### **통신**
- HTTP요청과 같은 네트워크 호출에 사용한다. 

### **JS 엔진**
- 자바스크립트 코드를 해석하고 실행한다.

### **UI 백엔드**
- select, input, 콤보 박스 등 기본적인 위젯을 그리는 인터페이스이다

**자료 저장소** 
- Cookie, Local Storage, Indexed DB 등 브라우저 메모리를 활용하여 저장하는 웹 데이터베이스이다. 

## 03. 렌더링 엔진
- 렌더링 엔진은 HTML, CSS를 파싱해 화면에 그려주는 역할을 한다. 
- 브라우저마다 사용하는 렌더링 엔진이 각각 다르기 때문에, 동일한 소스에 대해 다른 화면이 나올 수 있다. (크로스 브라우징 이슈)

### 렌더링 엔진 동작 과정
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZA_dkOy7q-gyejs2vU3HSBPo_4EDKp773rg&s">

### 1. DOM 트리 / CSSOM 트리 구축(파싱)

- 서버에서 응답 받은 HTML, CSS 문서를 HTML Parser, CSS Parser로 Object Model을 만든다.
- 이 때, 렌더링 엔진은 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 

### 1.1 DOM Tree 생성 과정

1. 서버는 브라우저로부터 요청 받은 HTML 파일을 읽은 후 > 메모리에 저장하고 > 그 메모리에 저장된 바이트(101101000100…)을 응답한다.

2. 브라우저는 응답 받은 바이트 형태의 문서를 meta태그의 **charset** attribute에 지정된 **인코딩** 방식(UTF-8)에 따라 문자열로 반환한다.

3. 문자열로 변환된 HTML문서를 문법적 의미를 갖는 코드의 최소 단위인 **토큰(token)**으로 분해한다.

4. 토큰의 내용에 따라 객체로 변환하여 노드를 생성한다. 

5. HTML의 모든 노드를 트리 구조로 구성하여 DOM을 만든다.

### 1.2 CSS파싱과 CSSOM 생성 과정
- 렌더링 엔진은 HTML문서를 한 줄 씩 파싱하며 DOM을 생성한다. 
- HTML를 한 줄씩 읽는 도중,  CSS를 로드하는 <link> 태그 혹은 <style> 태그를 만나면 서버에 CSS를 요청하고, 해당 CSS를 먼저 로드하고 파싱한다(CSSOM).


### 1.3 자바스크립트 파싱 과정
- 렌더링 엔진은 HTML 문서를 한 줄 씩  파싱하며 DOM을 생성한다. 
- 도중, 자바스크립트 파일을 로드하는 <script> 태그를 만나면 **DOM 생성을 일시 중단**한다.
- script 태그의 src에 정의된 자바스크립트 파일을 서버에 요청한 후, 응답받은 자바스크립트 코드를 파싱하기 위해 **자바스크립트 엔진에게 제어권을 넘긴다**.
- 자바스크립트 파싱이 끝나면 렌더링 엔진으로 다시 제어권이 돌아오고 DOM 생성을 이어나간다.
  - 이 때, **JavaScripts에서 생성되지 않은 DOM을 조작한다면 에러가 발생할 수 있다**.
  - 따라서 body 요소 아래에 자바스크립트를 위치시키거나, DOM 생성이 완료된 시점에 자바스크립트가 실행되도록 해야 한다. 

### 2. **렌더 트리 구축 (Attachment)**
- CSSOM 트리와 DOM 트리를 결합하여 **렌더 트리**를 형성한다(**Attachment)**

1. 렌더 트리를 형성하면 브라우저는 DOM 트리의 루트부터 노드 각각을 모두 탐색한다.
2. 이 때 화면에 표시되지 않는 노드(script, meta 태그 등..)와 속성(`display:none`)은 렌더 트리에서 제외한다.
    - `display:none` vs `visibility: hidden`
3. 화면에 표시되는 노드에 대한 CSSOM 규칙을 찾아 적용한다.
4. 화면에 표시되는 노드를 콘텐츠 및 계산된 스타일과 함께 렌더 트리로 만든다

### 03. 렌더 트리 배치(Layout / ReFlow)
- 기기의 뷰 포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산한다.
  - 뷰 포트 : 스크롤바가 없는 상태에서 보이는 부분
- 이때 CSS에 상대적인 값인 `%`, `rem` ,`vh` 등으로 할당된 값들은 절대적인 값인 `px` 단위로 변환된다

### 04. 렌더 트리 그리기(Paint)

**`Painting`** 메소드가 호출된 후 브라우저 화면에 UI가 나타나게 된다.

**그리기 순서**
- 실제로 요소가 stacking contexts에 쌓이는 순서는 아래와 같다. 
- 스택은 뒤에서 앞으로 그려지기 때문에 이 순서는 Painting에 영향을 미친다. 

<aside>
💡 배경 색 → 배경 이미지 → 테두리 → 자식 → 아웃 라인
</aside>

**동적 변경**
- 브라우저는 변경에 대해 가능한 한 최소한의 동작으로 반응하려고 노력한다. 예를 들어 `div`요소 한 개의 의 색깔이 바뀌면 해당 요소의 리페인팅만 발생한다.
- 반면, 요소의 위치, 크기의 변경, / 노드의 추가 등의 변화는 **해당 요소와 자식 그리고 형제의 리페인팅과 재배치가 발생한다**. 
- `html` 요소의 글꼴 크기를 변경하는 것과 같은 큰 변경은 캐시를 무효화하고 트리 전체의 배치(Layout)와 리페인팅이 발생한다.

### 05. Reflow / Repaint
- 브라우저에 페이지가 모두 그려진 후, 특정 액션이나 이벤트에 따라 HTML요소의 크기나 위치 등의 레이아웃 수치가 변하면 해당 요소의 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout(Reflow)과정을 다시 수행하게 된다.
- 이럴 경우 각 요소들의 크기와 위치를 다시 계산하게 되는데 이 과정을 Reflow, 그리고 Reflow 된 렌더 트리를 다시 화면에 그려주는 과정을 Repaint라고 한다.

즉 **화면의 구조가 변경되었을 때에는 Reflow와 Repaint 모두 발생하고, 화면의 구조가 변경되지 않는 변화는  Repaint만 발생한다.** 

**Repaint**
- `opacity`, `background-color`, `visibility`, `outline` 등의 스타일 변경 시에는 Repaint만 동작한다.

**Reflow**
- DOM 노드의 추가, 제거, 위치 변경, 크기 변경(margin, padding, border, width, height 등..)
- CSS3 애니메이션과 트랜지션
- 폰트 변경, 텍스트 내용 변경
- offset, scrollTop, scrollLeft과 같은 계산된 스타일 정보 요청
- 윈도우 크기 변경 등 화면 구조의 변화

<aside>
💡 브라우저가 렌더링을 빠르고 효율적으로 할 수 있게 개발하기 위해서는 Reflow과정을 최소화 시키는 것이 좋다.
.Reflow는 성능에 큰 영향을 미치기 때문에, 이를 최소화하는 것이 중요하다. 
  예를 들어, 스타일 변경을 그룹화하거나 transform, opacity 속성을 활용하는 것이 Reflow를 줄이는 데 효과적이다.
</aside>

## 04. 면접에서 자주 나오는 질문

### **1. 브라우저에 URL을 입력하면 어떤 과정이 일어나나요?**

브라우저가 URL을 입력받으면 다음과 같은 과정이 진행됩니다.

1. **DNS 조회**: URL의 도메인 이름을 IP 주소로 변환합니다.
2. **TCP 연결 수립**: 3-way handshake를 통해 클라이언트와 서버 간 연결을 설정합니다.
3. **HTTP 요청 전송**: 브라우저가 서버에 HTTP 요청(GET/POST 등)을 보냅니다.
4. **서버 응답 처리**: 서버가 HTML, CSS, JS 등 웹페이지를 구성하는 데이터를 응답합니다.
5. **렌더링 엔진 처리**: HTML을 파싱하여 DOM을 구성하고, CSS를 적용하며, JavaScript 실행 후 화면을 그립니다.
6. **화면 출력**: 최종적으로 웹페이지가 사용자에게 렌더링됩니다.


### **2. 브라우저의 렌더링 과정은 어떻게 이루어지나요?**

렌더링 엔진이 HTML, CSS, JavaScript를 받아 웹페이지를 화면에 표시하는 과정은 다음과 같습니다.

1. **HTML 파싱 → DOM 트리 생성**
2. **CSS 파싱 → CSSOM 트리 생성**
3. **DOM과 CSSOM을 결합 → 렌더 트리 생성**
4. **레이아웃(Layout) 계산 → 요소들의 위치와 크기 결정**
5. **페인팅(Paint) → 픽셀을 화면에 그리기**
6. **합성(Composite) → 최종 화면 출력**

이 과정에서 JavaScript는 DOM을 조작하며, 변경 사항에 따라 Reflow와 Repaint가 발생할 수 있습니다.


#### CSS와 HTML의 관계

HTML이 파싱되면서 브라우저는 해당 HTML 요소의 스타일을 적용하기 위해 CSS 파일을 요청합니다. 

CSS 파일이 외부에 있을 경우, 브라우저는 그 파일을 받아오기 전에 페이지 렌더링을 중단하고 기다립니다. 

이는 렌더링 차단자로 작용하며, 페이지의 스타일을 먼저 적용해야 하기 때문에, CSS는 HTML 파일의 상단에 선언하는 것이 중요합니다. 

그렇지 않으면, FOUC(Flash of Unstyled Content) 현상이 발생할 수 있습니다. 즉, 스타일이 적용되지 않은 채로 HTML 요소가 잠시 보이게 되는 현상입니다.


#### JS와 HTML의 관계

자바스크립트는 HTML 문서에서 선언된 순서대로 실행되며, 기본적으로 렌더링을 차단하는 특성이 있습니다. 

HTML을 파싱하는 중간에 <script> 태그를 만나면, 브라우저는 자바스크립트를 다운로드하고 실행할 때까지 HTML 파싱을 멈춥니다. 

만약 자바스크립트 파일이 HTML 문서 상단에 위치한다면, HTML 문서의 나머지 부분이 파싱되기 전에 스크립트가 실행될 수 있어, DOM이 아직 완전히 로드되지 않은 상태에서 자바스크립트가 실행될 수 있습니다. 

이로 인해 오류가 발생하거나 DOM 요소에 접근할 수 없는 문제가 생길 수 있습니다.

따라서 자바스크립트 파일은 일반적으로 HTML 파일의 하단에 선언하여, DOM이 완전히 로드된 후에 실행되도록 하는 것이 좋습니다. 

이를 통해 페이지 렌더링을 막지 않고, DOM 요소들이 완전히 준비된 상태에서 자바스크립트를 실행할 수 있습니다.



### **3. Reflow와 Repaint의 차이점은 무엇인가요?**

- **Repaint**: 색상이나 그림자 등 시각적 요소만 변경될 때 발생합니다. (ex. `background-color` 변경)
- **Reflow**: 요소의 크기나 위치가 변경되면 발생하며, 성능에 큰 영향을 미칩니다. (ex. `width`, `height`, `margin` 변경)

Reflow는 트리 전체를 다시 계산해야 하므로 성능 최적화를 위해 `transform` 속성을 활용하는 등의 기법을 사용할 수 있습니다.

### **4. HTML 문서에서 CSS 파일은 위에, JS 파일은 아래에 선언하는 이유는 무엇인가요?**

브라우저는 HTML을 파싱하여 DOM 트리를 만들고, CSS 파일을 받아 CSSOM 트리를 생성합니다. 

이 두 트리가 결합되어 렌더 트리가 형성됩니다. 이 후 레이아웃을 계산하고 화면에 그리게 되며, JS가 HTML 파싱 중간에 있을 경우 파싱을 멈추고 스크립트를 실행해 렌더링을 차단할 수 있습니다. 

따라서 CSS는 상단에 배치하여 스타일이 먼저 적용되도록 하고, JS는 하단에 배치하여 DOM 로딩 후 실행되도록 합니다.


### 5. **async와 defer의 차이점에 대해 설명해주세요.**

async 속성은 자바스크립트 파일이 HTML 파싱과 병행하여 비동기적으로 다운로드되고, 다운로드가 완료되면 즉시 실행됩니다. 

이때 **HTML 파싱은 중단**되며, 자바스크립트가 실행되기 전까지 기다립니다. 

실행 순서가 중요하지 않다면 async를 사용할 수 있지만, 여러 개의 async 속성의 스크립트가 있을 경우 실행 순서가 보장되지 않기 때문에 주의가 필요합니다.

반면 defer는 자바스크립트 파일을 HTML 문서의 파싱이 끝난 후, 즉 **DOM이 완전히 로드된 후 실행**되도록 합니다. 

여러 개의 defer 속성이 붙은 스크립트는 선언된 순서대로 실행됩니다. 

defer는 페이지 로드 성능을 높이는 데 유용하며, DOM을 다루는 스크립트에서 유용합니다.
