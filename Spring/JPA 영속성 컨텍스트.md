# 00. 개요

## 영속성(persistence)이란?

- 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성
- 영속성을 갖지 않으면:
    - 데이터는 메모리에만 존재함
    - 프로그램이 종료되면 해당 데이터는 모두 사라지게 됨

## 영속성 in JPA

- JPA의 엔티티 매니저가 트랜잭션 안에서 DB 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태임
- 이 상태에서 해당 데이터를 변경하면 트랜잭션이 끝나는 시점에 DB에 변경 내용을 반영함
    
    → **dirty checking**
    

+) 엔티티 매니저(Entity Manager): 영속성 컨텍스트에서 엔티티를 관리하고 필요에 따라 DB의 데이터를 CRUD하는 작업을 담당하는 객체

![Image](https://github.com/user-attachments/assets/f3cb505d-28bf-4166-aafa-ad8bf69f8c2a)

## 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 **가상의 데이터베이스** 같은 역할
- 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면:
    - 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
    - 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되면, 해당 객체를 영속 객체라고 부름
- e.g. `em.persist(member)`
    
    엔티티 매니저로 회원 엔티티를 영속성 컨텍스트에 저장하겠다는 뜻
    

### 구조

![Image](https://github.com/user-attachments/assets/e3d52e6e-3819-4a63-a87e-e18a32ec4ea9)

**1차 캐시 저장소**

- 영속성 컨텍스트가 관리하는 엔티티 정보 보관
- 여기에 저장된 엔티티는 ‘영속’ 상태임
- 아직 DB에 저장된 상태는 아님

**쿼리문 저장소(SQL 저장소)**

- 필요한 쿼리문을 보관
- 최대한 여러 쿼리문을 모아 두고 DB에 접근하는 횟수를 최소화하여
- 성능 이점을 얻기 위함
- 저장해둔 쿼리문으로 DB에 접근하는 동작은 엔티티 매니저의 `flush()` 로 수행됨

# 01. 생명 주기

![Image](https://github.com/user-attachments/assets/3f343b87-4c07-47c0-b84f-22e8a97b2f51)

- 영속성 컨텍스트는 **세션 단위**의 생명주기를 가짐
- DB 접근을 위한 세션이 생성되면 영속성 컨텍스트가 만들어지고,
- 세션이 종료되면 영속성 컨텍스트도 없어짐
- 엔티티 매니저는 이러한 일련의 과정에서 영속성 컨텍스트에 접근하기 위한 수단
- **엔티티가 PK를 알고 있는지**가 주요 구분 사항

![Image](https://github.com/user-attachments/assets/3e7a4f09-a00c-48c9-baef-ee60199f546a)

## 비영속(new/transient) 상태

- 영속성 컨텍스트와 전혀 관계가 없는 상태
- PK 없음

## 영속(managed) 상태

- 영속성 컨텍스트에서 관리되고 있는 상태
- **아직 DB에 저장된 상태가 아님**
- PK 있음
- `persist()`, `find()`로 비영속 상태의 엔티티를 영속 상태로 만들 수 있음

### 예시1. `persist()`와 `flush()`

1. `persist()`
    
    ![Image](https://github.com/user-attachments/assets/9c4d4aa0-43a5-459f-b0c0-7e6eee34b0ff)
    
    - 엔티티에 대한 insert query가 생성되었지만 아직 DB에는 전달되지 않고 쿼리문 저장소에 보관되어 있는 상태
    - `flush()`가 실행되기 전에는 실제 DB에 접근하지 않음
2. 여러 번의 `persist()`
    
    ![Image](https://github.com/user-attachments/assets/3f5338db-b09d-451e-b876-54b9723b6b59)
    
    - insert query가 계속 보관되는 중
3. `flush()`
    
    
    ![Image](https://github.com/user-attachments/assets/9d73cf6b-cb4f-4930-b3e5-8b33b81b9329)
    
    - 모아둔 쿼리문은 flush()가 실행될 때 DB에 반영됨
    
    → **트랜잭션을 지원하는 쓰기 지연(transactional write-behind)**
    
    - `flush()`를 하더라도 1차 캐시에서 관리되던 엔티티가 사라지지는 않음
    - `flush()`의 용도는 **영속성 컨텍스트와 DB를 동기화**하는 것

### 예시2. `find()` 동작과정

![Image](https://github.com/user-attachments/assets/55bf7175-eb1f-4b74-be23-f4880fc35afa)

1. 1차 캐시에서 엔티티 찾기
2. 없다면 데이터베이스에서 조회
3. 1차 캐시에 조회한 엔티티 저장
4. 엔티티 반환

❓ 만약 같은 entity를 한번 더 조회하면?

A. 1차 캐시에 있는 엔티티를 반환하고 DB 접근은 일어나지 않음

→ JPA가 조회와 관련한 성능에서 큰 이점을 취할 수 있는 이유

- **영속 엔티티의 동일성 보장**
    
    ```java
    Person person = new Persion(1, "na"); //id, name
    entityManager em = new EntityManager();
    em.persist(p1);
    
    Person p1 = em.find(Person.class, 1);
    Person p2 = em.find(Person.class, 1);
    
    System.out.println(p1 == p2); // true
    ```
    

## 준영속(detached) 상태

- 영속성 컨텍스트에서 관리되던 엔티티가 더 이상 관리되지 않는 상태
- 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않음
- PK 있음
- 엔티티 매니저의 `merge()`로 다시 영속 상태로 변환할 수 있음

### 엔티티 준영속 상태로 만들기

1. **`detach()`** : 특정 엔티티를 준영속 상태로 만듦
2.  **`clear()`**: 영속성 컨텍스트 전체를 초기화(쿼리문 저장소에 있던 쿼리문도 초기화됨)
3. **`close()`**: 영속성 컨텍스트(엄밀히 말하면 엔티티 매니저)를 닫음

## 삭제(removed) 상태

- 엔티티 매니저를 영속성 컨텍스트에서 관리하지 않고, 해당 엔티티를 DB에서 삭제하는 delete query를 보관하는 상태
- PK 없음
- `flush()`가 호출되기 전까지 쿼리문이 DB에서 수행되지 않음

![Image](https://github.com/user-attachments/assets/556feff8-5ece-480b-9215-969e69dbce4e)

# 02. 특징과 장점

## 특징

1. 영속성 컨텍스트의 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값(@Id)으로 구분
2. 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영(flush)
3. 영속성 전이(persistence cascade)
    - 부모 엔티티의 영속성을 자식 엔티티로 전파시키는 것
    - 부모가 영속화되었다면 영속성 전이를 통해 별다른 작업 없이도 자식 또한 영속화됨

## 장점

1. **1차 캐시**
    - 영속성 컨텍스트 내부 캐시로, 영속 상태의 엔티티가 저장되는 곳
    - find()로 조회
2. **동일성 보장**
3. **트랜잭션을 지원하는 쓰기 지연(transactional write-behind)**
    - 엔티티 매니저는 트랜잭션을 커밋하기 전까지 내부 쿼리 저장소에 insert query를 모아 두고,
    - 커밋할 때 모아둔 쿼리를 DB에 보냄
4. **변경 감지(dirty checking)**
    - JPA로 엔티티를 수정할 때는 엔티티 조회해서 변경만 하면 됨
5. **지연 로딩(lazy loading)**
    - 연관관계에 있는 엔티티를 조회할 때 한번에 가져오지 않고
    - 필요할 때 가져오는 것
    - 연관관계에 있는 객체는 프록시 상태로, 초기화되지 않은 상태로 존재함

# 03. 자주 나오는 질문

## 영속성 컨텍스트에 대해 설명해 주세요.

영속성 컨텍스트는 데이터를 영구 보관하는 환경으로서, 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 데이터베이스 역할을 합니다.

영속성 컨텍스트는 엔티티 매니저가 생성될 때 1대 1로 생성됩니다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근하여 데이터를 다룰 수 있습니다.

## 영속성 컨텍스트의 장점이 뭔가요?

1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 다섯 개의 장점이 있습니다.

(이하생략..)

## 영속성 컨텍스트의 생명 주기는 어떻게 이루어지나요?

영속성 컨텍스트의 생명 주기는 비영속, 영속, 준영속, 삭제의 흐름으로 이루어집니다.

처음에는 비영속 상태로, 자바 객체로만 존재하고 영속성 컨텍스트와는 아무런 관련이 없는 상태를 말합니다. 예를 들어, `new` 로 객체를 만든 직후와 같은 상황입니다.

이후 엔티티 매니저의 `persist()`를 호출하면 영속 상태로 전환됩니다. 엔티티가 영속 상태이면 영속성 컨텍스트가 해당 객체를 관리하고, 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영됩니다. 추가적으로, 엔티티 매니저의 `find()`로 기존 객체를 조회할 때도 해당 객체가 영속 상태가 됩니다.

엔티티 매니저의 `deatch()`를 호출하거나, 영속성 컨텍스트가 종료된다면 해당 엔티티는 준영속 상태가 됩니다. 준영속 상태가 되면 영속성 컨텍스트가 이 객체를 관리하지 않아서, 변경 사항이 있어도 DB에 반영되지 않습니다.

마지막으로 엔티티 매니저의 `remove()` 를 호출하면 삭제 상태가 됩니다. 삭제 상태는 트랜잭션 커밋 시점에 데이터베이스에서 실제로 삭제됩니다.

# 참고자료

https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80

https://siyoon210.tistory.com/138

https://velog.io/@zxzz45/%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91JPA

https://thisdev.tistory.com/entry/JPA-%EA%B4%80%EB%A0%A8-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A7%88%EB%AC%B8-50%EA%B0%80%EC%A7%80

### 더 알아보기: 영속성 전이

https://goalinnext.tistory.com/118
