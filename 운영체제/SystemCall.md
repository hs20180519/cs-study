# 01. System Call이란 ?

> 시스템 호출(System Call)은 운영체제 커널이 제공하는 서비스와 기능을 응용 프로그램이 사용할 수 있도록 하는 인터페이스이다.
> 

즉, 응용 프로그램이 운영체제의 기능을 사용하려고 할 때, 직접 하드웨어를 제어하거나 커널의 중요한 데이터를 접근할 수 없기 때문에, 시스템 콜을 통해 간접적으로 운영체제의 커널 기능을 호출하게 된다.

</br>

# 02. System Call의 역할

운영체제는 응용 프로그램과 하드웨어 사이의 중간 계층을 역할을 한다. 시스템 콜은 응용 프로그램이 직접 하드웨어와 상호작용하지 않고도 운영체제를 통해 하드웨어와 통신할 수 있게 한다. 이를 통해 다음과 같은 역할을 수행한다.

1. 하드웨어 자원 접근 관리 : 파일 시스템 접근, 메모리 할당, 네트워크 통신 등 하드웨어와 관련된 작업들을 운영체제가 직접 관리하게 한다.
2. 보안 및 안정성 제공 : 시스템 콜을 통해 응용 프로그램이 커널 모드에서 실행되는 코드에 직접 접근하지 못하게 하여 시스템의 보안과 안정성을 유지한다.
3. 추상화 계층 제공 : 응용 프로그램이 다양한 하드웨어 장치나 저수준 작업에 대해 알 필요 없이 고수준의 추상화된 인터페이스만으로 기능을 수행할 수 있도록 한다.

</br>

# 03. System Call의 종류

1. 프로세스 제어
    - 새로운 프로세스를 생성하거나 종료할 때 사용한다.
        - `fork()`
            
            현재 실행 중인 프로세스를 복제하여 새로운 프로세스를 생성하는 역할이다.
            새로운 프로세스는 "자식 프로세스"라고 부르며, 복제된 원본 프로세스는 "부모 프로세스"라고 한다.
            
            - 프로세스 복제 : 부모 프로세스의 주소 공간을 그대로 복사하여 자식 프로세스를 생성하기 때문에, **동일한 메모리 공간**을 가지며, 동일한 프로그램 코드를 실행한다.
            - **프로세스 ID (PID) 차이** : fork()가 호출되면 자식 프로세스에는 새로운 프로세스 ID(PID)가 할당된다. **부모 프로세스에서는 fork()가 자식 프로세스의 PID를 반환**한다. **자식 프로세스에서는 fork()가 0을 반환**한다.
            - **메모리 공유 및 복사 - 쓰기** : 처음에는 부모와 자식이 동일한 메모리 공간을 공유하지만, 둘 중 하나가 메모리를 수정하려고 할 때, 실제로는 수정되는 메모리 부분만 복사하여 별도의 메모리 공간으로 변경한다. 이 방식을 통해 메모리 사용을 효율적으로 관리할 수 있게 된다.
            - **다중 프로세스 병렬 실행** : 여러개의 프로세스를 동시에 생성하고 병렬로 작업을 수행할 수 있다. 부모 프로세스는 파일을 읽는 동안 자식 프로세스는 데이터를 처리할 수 있다.
            
            ```c
            #include <stdio.h>
            #include <unistd.h>
            
            int main() {
                pid_t pid = fork(); // 새로운 프로세스 생성
            
                if (pid < 0) {
                    // fork 실패 시
                    perror("fork failed");
                    return 1;
                } else if (pid == 0) {
                    // 자식 프로세스
                    printf("This is the child process with PID: %d\n", getpid());
                } else {
                    // 부모 프로세스
                    printf("This is the parent process with PID: %d and child PID: %d\n", getpid(), pid);
                }
            
                return 0;
            }
            ```
            
            이 예제에서 fork()가 호출되면 두 개의 프로세스가 동시에 실행된다. pid값이 0이면 자식 프로세스임을 의미하고, 0보다 크면 부모 프로세스에서 자식의 PID를 반환받았음을 의미한다.
            
        - `exec()`
            
            현재 실행중인 프로세스를 다른 프로그램으로 대체하는 데 사용된다.
            
            - 프로그램 대체 : 현재 프로세스의 메모리 영역을 새 프로그램으로 완전히 덮어 쓴다. 이때 기존 프로세스의 코드, 데이터, 힙, 스택 영역이 모두 새로운 프로그램으로 대체된다.
            - 새로운 프로그램 실행 : exec() 시스템 콜이 성공하면, 새로 교체된 프로그램의 첫 번째 명령이 실행된다. 이 과정에서 기존 프로그램의 메모리 공간이 모두 사라지기 때문에, exec()가 호출된 이후로는 이전의 코드로 돌아갈 수 없다.
            - 호출 실패 시 : 실패시 -1을 반환하고, errno 변수를 통해 오류 코드를 설정한다.
            
            ```c
            #include <stdio.h>
            #include <unistd.h>
            
            int main() {
                pid_t pid = fork(); // 새로운 프로세스 생성
            
                if (pid < 0) {
                    // fork 실패 시
                    perror("fork failed");
                    return 1;
                } else if (pid == 0) {
                    // 자식 프로세스에서 새로운 프로그램 실행
                    printf("Child process will execute 'ls' command.\n");
                    execlp("ls", "ls", "-l", NULL); // "ls -l" 명령어를 실행
                    perror("exec failed"); // exec 실패 시 오류 메시지 출력
                } else {
                    // 부모 프로세스는 자식 프로세스가 종료될 때까지 대기
                    wait(NULL);
                    printf("Parent process completes.\n");
                }
            
                return 0;
            }
            
            ```
            
            이 예제에서 fork()로 자식 프로세스를 생성한 후, 자식 프로세스는 execlp()를 호출하여 현재 프로세스를 ls-l 명령어로 대체한다. exec호출이 성공하면 perror(”exec failed”)는 실행되지 않으며, ls-l 명령어의 출력이 화면에 표시된다. 부모 프로세스는 자식 프로세스가 종료될 때까지 wait()로 대기한다.
            
        - `wait()`
            
            wait() 시스템 콜은 부모 프로세스가 자식 프로세스의 종료를 기다리게 하는데 사용된다. 자식 프로세스가 종료될 때까지 부모 프로세스는 블록 상태로 대기한다.
            
            - 부모 프로세스가 wait()을 호출하면, 부모 프로세스는 자식 프로세스가 종료될 때까지 기다린다.
            - 자식 프로세스가 종료되면, wait()는 자식 프로세스의 종료 상태를 반환한다. 자식 프로세스가 종료되기 전까지 부모 프로세스는 실행을 중단하고 기다린다.
            
            ```c
            #include <stdio.h>
            #include <sys/types.h>
            #include <sys/wait.h>
            #include <unistd.h>
            
            int main() {
                pid_t pid = fork();
            
                if (pid < 0) {
                    // fork 실패
                    perror("fork failed");
                    return 1;
                } else if (pid == 0) {
                    // 자식 프로세스
                    printf("Child process is running with PID: %d\n", getpid());
                    sleep(2); // 2초 대기
                    printf("Child process is exiting\n");
                    return 0;
                } else {
                    // 부모 프로세스
                    printf("Parent process is waiting for child to exit.\n");
                    wait(NULL); // 자식 프로세스 종료 대기
                    printf("Parent process detected child exit.\n");
                }
            
                return 0;
            }
            ```
            
            이 예제에서, 부모 프로세스는 자식 프로세스가 종료될 때까지 wait()을 사용하며 기다린다.
            
        
2. 파일 조작 : 파일을 생성, 삭제, 읽기 쓰기 등 파일에 관련된 작업을 수행할 때 사용한다.
    - `open()`, `read()`, `write()`, `close()`, `unlink()`
    
3. 장치 조작 : 장치를 제어하거나 데이터 전송을 위해 사용한다.
    - `ioctl()`, `read()`, `write()`
    
4. 정보 유지 : 시스템에 대한 정보나 프로세스의 정보를 가져오거나 설정할 때 사용한다.
    - `getpid()`, `alarm()`, `sleep()`, `gettimeofday()`
    
5. 통신 : 프로세스 간 통신(IPC, Inter-Process Communication)이나 네트워크 통신을 위해 사용된다.
    - `pipe()`, `shmget()`, `mmap()`, `socket()`
    
6. 메모리 관리 : 메모리를 동적으로 할당하거나 해제할 때 사용한다.
    - `brk()`, `mmap()`, `munmap()`

</br>

# 04. System Call의 작동 방식

1. 유저 모드에서의 요청 : 응용 프로그램이 시스템 콜을 호출하면, CPU는 유저 모드에서 실행되고 있는 응용 프로그램을 잠시 중단하고 커널 모드로 전환된다. (이 전환을 **트랩**이라고 부른다.)
2. 커널 모드에서의 처리 : 커널 모드로 전환된 후, 커널은 시스템 콜 요청을 처리한다.
3. 결과 반환 : 요청이 처리된 후, 커널은 다시 유저 모드로 전환하고 응용 프로그램에 결과를 반환한다. 결과가 성공적이면 데이터나 상태 코드가 반환되고, 실패하면 오류 코드가 반환된다.
4. 유저 모드로의 복귀 : 커널 모드에서의 작업이 끝나면 CPU는 다시 유저 모드로 전환되어, 응용 프로그램이 그 결과를 사용하여 이후의 작업을 계속할 수 있게 된다.

</br>

# 05. System Call의 중요성

시스템 콜은 응용 프로그램과 운영체제 간의 통신을 가능하게 하는 매우 중요한 매커니즘이다. 이를 통해 응용 프로그램은 커널이 제공하는 서비스들을 활용하여 복잡한 시스템 작업을 수행할 수 있으며, 시스템의 보안과 안정성을 유지하면서도 다양한 기능을 효율적으로 사용할 수 있다.

---

## [ 한국은행 2023년 기출 문제 ]

![image](https://github.com/user-attachments/assets/48a77018-6b92-4ba4-b8fb-b821d1737a74)

</br>

![image](https://github.com/user-attachments/assets/88e0ff7e-74c2-47ec-999b-70022043fcd9)

