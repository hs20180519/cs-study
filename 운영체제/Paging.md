# 가상 메모리

- 물리 메모리 크기의 한계를 극복하기 위해 사용하는 기술
- 물리 메모리보다 큰 프로세스를 수행하거나, 여러 프로세스를 실행시킬 수 있다.

### 기본 아이디어

- 프로세스의 모든 부분이 물리 메모리에 올라갈 필요는 없음

→ 실행에 필요한 프로세스 일부만 물리 메모리에 적재하여 한정된 메모리 내에서 큰 프로세스 or 여러 프로세스를 수행이 가능하도록 한다.

→ 프로세스 입장에서는 가상메모리 공간도 물리메모리 공간으로 인식

![virtualMemory](https://github.com/user-attachments/assets/0b1dd7cd-6a02-4f16-80fb-a1f32dc5ae53)

### 물리 주소와 논리(가상) 주소

- 물리 주소
    - 프로세스가 실제 배치되는 메모리상 위치
    - 컴퓨터의 물리 메모리를 접근할 때 사용
- 논리 주소
    - 프로세스가 참조하는 주소
    - 논리 주소는 프로세스마다 중복될 수 있으며, 어떤 프로세스에 해당하는 논리 주소인지에 따라 다르게 해석된다.
    - 프로세스가 메모리에 적재될 때 할당되는 가상의(독자적인) 위치
    

**주소 변환**

- 프로세스는 논리 주소를 다룬다. 따라서 물리 메모리로 접근하기 위해서는 논리 주소를 물리 주소로 변환(매핑)하는 과정이 필요하다.
- MMU(Memory Management Unit)에서 변환 작업을 수행

![image.png](https://github.com/user-attachments/assets/32626e76-0e95-43e3-8e10-aaf5bb6a997b)

## 물리 메모리 관리

- 연속 메모리 할당 방식: 프로세스를 통째로 메모리에 할당하는 방식
- 불연속 메모리 할당 방식: 프로세스를 분산하여 메모리에 할당

# 페이징

- 불연속 메모리 할당 방식 중 하나
- 외부 단편화를 해결할 수 있음
- 프로세스를 동일한 크기의 조각(**페이지**)으로 나누어 관리
- 프로세스가 점유할 메모리 공간을 각 페이지로 분할하여 물리 메모리에 올린다.
- 프로세스가 현재 참조하고 있는 페이지가 물리 메모리에 있다면 그 프로세스는 수행될 수 있다.

## 프레임

- 물리 메모리 공간을 **페이지와 같은 크기**로 분할한 고정 크기 블록
- 페이지가 하나의 프레임을 할당받으면 물리 메모리에 위치하게 되며,
- 프레임을 할당받지 못한 페이지들은 외부 저장장치(Backing store)에 저장된다.

## 페이지 테이블

- 프레임과 페이지 간의 매핑 정보를 담고 있는 데이터 구조
- 프로세스는 연속적으로 수행되어야 하는데, 물리 메모리에 불연속적으로 배치되어 있으면 순차적으로 실행할 수 없다.
- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 알 수 없기 때문

→ 페이지 테이블로 논리 주소와 물리 주소를 매핑하여 물리 주소에는 불연속적으로 위치하고 있더라도 논리 주소는 연속적으로 배치되도록 한다.

- 실제 주소 변환은 MMU가 수행
- 프로세스마다 존재 → n개의 프로세스가 있다면 page table도 n개

![image.png](https://github.com/user-attachments/assets/af33fb92-41eb-41ed-97c4-0c1268e75d3c)

![image.png](https://github.com/user-attachments/assets/26686647-2fc2-4944-837f-365c29bb20cb)

### 페이지 테이블 엔트리

- 프레임 번호, 페이지 번호, 유효 비트 등
- 유효 비트(valid bit)
    - 현재 해당 페이지에 접근 가능한지 여부를 나타냄
    - 일반적으로 프로세스를 이루는 모든 페이지가 물리 메모리에 로드되어 있지 않고 일부는 스왑 영역에 있는 경우가 많다. 이런 경우 유효 비트는 현재 페이지가 물리 메모리에 적재되어 있는지, 스왑 영역에 있는지를 알려준다.
    - 물리 메모리에 적재되어 있다면 1, 아니면 0

![image (4)](https://github.com/user-attachments/assets/bd79b97d-08ed-4c43-8df1-0ad6166a2051)

## demand paging(요구 페이징)

paging 방식을 사용하면 프로세스에서 나눠진 page를 언제 물리 메모리에 올려놓을지에 대한 정책이 필요하다.

demand paging은 프로그램 실행 도중에 요청되는(필요한) 페이지만 물리 메모리에 적재하는 방식이다.

<aside>
💡 동작과정

1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지가 물리 메모리에 있을 경우(유효 비트 1) CPU는 적제된 프레임에 접근
3. 해당 페이지가 물리 메모리에 없을 경우(유효 비트 0) page fault 발생
4. 해당 페이지를 물리 메모리에 적재하고 유효 비트를 1로 설정
5. 1번 수행
</aside>

![image (5)](https://github.com/user-attachments/assets/b721e9c8-4a75-403e-9a03-95d48882c2a5)

## Page fault

- demand paging 중, 참조하려는 페이지가 물리 페이지가 없는 경우 발생한다.

# 페이지 교체 알고리즘

- 요구 페이징을 실행할 때, 현재 물리 메모리에 비어 있는 프레임이 없는 경우 현재 메모리에 올라가 있는 페이지를 스왑 영역으로 내보내고 새로운 페이지를 물리 메모리에 로드해야 한다.
- 페이지 교체 알고리즘은 이러한 상황에서 어떤 페이지를 내보낼 것인지 결정하는 알고리즘이다.

## FIFO (first-in-first-out)

- 가장 오래된 페이지부터 우선적으로 교체
- 가장 간단함
- 성능은 보장되지 않음

## OPT (optimal)

- 가장 오랫동안 사용하지 않은 페이지부터 우선적으로 교체
- 가장 낮은 page-fault 발생 비율을 보장하는 이론상 최적의 알고리즘
- 앞으로 적재할 page 번호를 미리 다 알고 있어야 하는데 알 수 없으므로, 실제로 구현이 불가능하다.

## LRU (Least Recently Used)

- 최근에 가장 적게 사용된(가장 오랜 시간 동안 참조되지 않은) 페이지부터 우선적으로 교체
- 구현방법
    1. Counter: 마지막으로 접근 요청된 시점을 기록
    2. Queue: 한 번 사용된 페이지를 큐의 가장 위로 이동

## LFU (Least Frequent Used)

- 사용 빈도가 가장 적은 페이지부터 우선적으로 교체
- 사용 빈도를 기록해 두어야 하고, 가장 적은 프레임을 찾아야 하는 오버헤드 있음

## NUR (Not Used Recently)

- 최근에 사용하지 않은 페이지부터 우선적으로 교체
