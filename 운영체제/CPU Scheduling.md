## 01. CPU 스케줄링

CPU 스케줄링이란, 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것이다.   
즉, 프로세스들의 실행 순서를 정해준다. 준비 상태에 있는 프로세스 중 어느 프로세스에게 CPU를 할당할 것인지 결정한다.   
CPU 스케줄링은 컴퓨터 성능과도 직결되고, 반드시 실행되어야 할 프로세스들이 실행되지 못하는 등
무질서한 상태가 발생할 수 있기 때문에 중요하다.

### 성능 척도
1. 처리량 Throughput : 단위 시간 당 완료되는 작업 수
2. 대기 시간 Waiting Time : 프로세스가 CPU를 할당받기 위해 기다린 시간
3. 응답 시간 Response Time : 프로세스가 처음 요청을 한 시점부터 첫 응답이 있을 때까지의 시간
4. 반환 시간 Turnaround Time : 프로세스가 시작부터 완료될 때까지 걸린 전체 시간 (종료시간 - 시작 시간)

</br>

## 02. 스케줄링 큐

운영체제는 각 프로세스의 PCB(Process Control Block)에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.   
하지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 찾기는 비효율적이다.   
그래서 CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 큐에 넣는다.   
운영체제는 이 큐를 **스케줄링 큐**로 구현하고 관리한다.   
(단, 큐는 반드시 선입선출 방식은 아니다)   
* PCB : 특정한 프로세스의 정보를 포함하는 커널의 자료 구조로, 문맥 교환시 PCB를 이용한다.
  <img width="177" alt="image" src="https://github.com/user-attachments/assets/6f1bbc62-1df3-4931-8148-b11cda67d87e">


- 준비 큐 : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐 : 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
![image](https://github.com/user-attachments/assets/66d8fe1e-570d-4180-a7ad-a5ee66e3e963)

</br>

## 03. CPU 스케줄링의 분류 (시스템 자원 관리 관점)

1. 단기 스케줄링 : 프로세스가 CPU에 할당되어 즉시 실행될지 결정하는 스케줄링이다. 준비상태에서 실행 상태로 전환되는 시점을 관리한다.
2. 중기 스케줄링 : 메모리에 있는 프로세스를 일시 중단(스와핑)하거나 다시 재개하는 역할을 한다. 일시 중단 상태로 들어갔다가 다시 준비 상태로 돌아가는 과정을 관리한다.
3. 장기 스케줄링 : 프로세스가 시스템으로 들어올 때 실행할지 여부를 결정하는 스케줄링이다. 시스템이 동시에 처리할 수 있는 프로세스의 수를 조절한다.
<img width="756" alt="image" src="https://github.com/user-attachments/assets/f8f872f3-dfaa-4ef7-9be6-373f87852e15">


</br>

## 04. CPU 스케줄링의 분류 (스케줄링의 동작 방식 관점)
### 1. 선점형 스케줄링    
프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 잇는 스케줄링 방식이다.   
장점 : 프로세스의 자원 독점을 막고 골고루 자원 분배가 가능하다.   
단점 : Context Switching 과정에서 오버헤드가 발생할 수 있다.

### 2. 비선점형 스케줄링   
하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식이다.   
장점 : Context Switching 과정에서 오버헤드가 선점형 스케줄링보다 적다.   
단점 : 하나의 프로세스가 자원을 사용 중이라면 당장 자원이 필요하는 상황에서도 기다려야 한다. 모든 프로세스가 골고루 자원을 사용할 수 없다.   

</br>

## 05. 스케줄링 알고리즘의 종류

## 비선점형
### (1) 선입 선처리 스케줄링(FCFS)
**First Come First Served Scheduling**   
준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.   
17ms 동안 CPU를 이용하는 프로세스 A, 5ms 동안 CPU를 이용하는 프로세스 B, 2ms 동안 CPU를 이용하는 프로세스 C가 차례대로 준비 큐에 삽입된다면,
프로세스 C는 고작 2ms를 실행하기 위해 22ms(17 + 5)라는 긴 시간을 기다려야 한다. 이를 **호위 효과(Convey Effect)**라고 한다.

</br>

### (2) 최단 작업 우선 스케줄링 (SJF)
**Shortest Job First**   
준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식이다.   
위의 예시에서 C와 B부터 실행한다면, C는 기다릴 필요가 없고, B는 2ms, A는 7ms만 기다리면 된다.   
(기본적으로 비선점형 스케줄링 알고리즘이지만, 최소 잔여 시간 우선 스케줄링을 통해 선점형으로 구현될 수 있다.)

</br>

### (3) 최고 응답률 우선 (HRN)
**Highest Response Ratio Next**   
응답률을 기준으로 대기 시간이 긴 프로세스를 우선적으로 실행하는 스케줄링 방식이다.   
응답률(Response Ratio) = (대기 시간 + 서비스 시간) / 서비스 시간   
공정하고, 대기 시간 감소의 장점이 있지만, 복잡하고 변동성이 있어 ㅁ든 프로세스가 균등하게 처리되지 않을 수 있다.   
프로세스 A의 대기 시간이 10초, 서비스 시간이 5초일 때 응답률은 (10+5)/5 = 3이고,   
프로세스 B의 대기 시간이 20초, 서비스 시간이 10초일 때 응답률은 (20+10)/10 = 3이다.   
이때 두 프로세스의 응답률은 같지만, 대기 시간이 긴 프로세스 B를 먼저 처리한다.

</br>

### 선점형
### (1) 라운드 로빈 스케줄링 (RR)
**Round Robin**   
선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다.   
타임 슬라이스란, 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.   
즉, 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다.   
<img width="677" alt="image" src="https://github.com/user-attachments/assets/a8c242e0-0528-4525-b018-79a9d33eb070">

</br>

### (2) 최소 잔여 시간 우선 스케줄링 (SRT)
**Shortest Remaining Time**   
최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다.   
최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.   
<img width="578" alt="image" src="https://github.com/user-attachments/assets/af3cb6fe-a4a9-42e7-aed3-d18df10e8714">
타임 슬라이스가 1초일 때 : A - B - C - B - C - B - A - B - A ...   
타임 슬라이스가 2초일 때 : A - A - C - C - B - B - A - A - B - B - A - A ...

</br>

### (3) 우선순위 스케줄링
프로세스들에게 우선 순위를 부여하고, 가장 높은 우선 순위를 가진 프로세스부터 실행하는 스케줄링 방식이다.   
SRT, SJF등은 우선 순위 스케줄링의 일종으로 볼 수 있다. 작업 시간이 짧은 프로세스에 높은 우선순위를 부여하거나, 남은 시간이 짧은 프로세스에 우선 순위를 부여했기 때문이다.   
다만, **기아 Starvation** 현상이라는 치명적인 단점이 존재한다.   
우선 순위가 높은 프로세스만 계속 먼저 실행되니 우선순위가 낮은 프로세스의 실행은 계속 뒤로 밀린다.   
이를 방지하기 위해 **에이징**을 사용한다. 오랫동안 대기한 프로세스의 우선 순위를 점차 높이는 방식이다.

</br>

### (4) 다단계 큐 스케줄링
우선순위 스케줄링의 발전된 형태로, 우선순위별 준비 큐를 여러 개 사용하는 스케줄링 방식이다.
큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.   

</br>

### (5) 다단계 피드백 큐 스케줄링
다단계 큐 스케줄링의 발전된 형태로, 프로세스들이 큐 사이를 이동할 수 있다.   
기존 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없어 기아 현상이 발생할 수 있는데, 이를 보완한 알고리즘이다.   
즉, 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘이다.

</br>


TODO : 문제 추가   
TODO : 자주 나오는 질문 추가

[사진 출처 : 혼자 공부하는 컴퓨터 구조 + 운영체제]

