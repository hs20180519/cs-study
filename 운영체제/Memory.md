# 01. 메모리란?

- 컴퓨터에서 정보를 처리하기 위해 정보를 보관하는 기억 장치
- 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.
- 접근 속도의 차이를 두기 위해 여러 가지 메모리가 계층 구조를 이룬다.
    - 레지스터 > 캐시 > 주기억장치 > 보조기억장치(하드디스크, SSD 등)

### 저장 장치 계층 구조

- 컴퓨터가 사용하는 저장 장치를 CPU와의 거리를 기준으로 계층적으로 나타낸 것
- CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
- 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.

⇒ 빠르면서 용량이 큰 저장 장치는 존재하기 어렵다.

![image](https://github.com/user-attachments/assets/5897b5bb-22e7-4273-b615-933a900d1d53)

## 메인 메모리

- RAM(Random Access Memory)
- 프로그램이 실행 중 = 메인 메모리에 프로세스가 올라감
- 휘발성 저장 장치
    
    → 컴퓨터 전원을 끄면 메인 메모리에 저장되었던 명령어와 데이터가 모두 사라짐
    
- RAM의 용량이 크면 프로그램 실행 속도가 높아지고 동시에 여러 프로그램을 실행하는 데 유리하다.
    
    → 보조기억장치에서 프로그램을 가져오는 시간이 줄어들기 때문
    

### 주소 공간

**물리 주소**

- 물리 메모리가 사용하는 주소
- 프로세스가 실행되기 위해 RAM에 올라가는 실제 위치

**논리 주소**

- CPU와 실행 중인 프로그램이 사용하는 주소
    
    → 이들은 물리 메모리 내에 프로그램이 저장된 위치가 어딘지 모른다.
    
- 프로세스마다 독립적으로 가지는 주소 공간으로, 0번지부터 시작
- 각각의 프로세스는 0번지부터 시작하는 자신만의 주소 공간이 있다.

### **주소 변환과 MMU**

- CPU와 메모리가 상호작용하기 위해서는 논리 주소와 물리 주소 간 변환이 필요함
- 메모리 관리 장치(MMU, Memory Management Unit)가 변환의 역할을 수행

**MMU**

- CPU가 가지고 있는 논리 주소에 베이스 레지스터 값을 더해 논리 주소를 물리 주소로 변환
- 베이스 레지스터: 프로세스의 물리 메모리 시작 주소 정보
- 접근하려는 데이터의 물리 주소 = 베이스 레지스터 + 논리 주소(offset)
- context switch가 발생할 때마다 베이스 레지스터의 값이 변경된다.

💡 그렇기 때문에, 같은 논리주소라도 현재 CPU가 실행하고 있는 프로세스가 누구냐에 따라 다른 물리 주소를 가지게 되는 것

![image.png](https://github.com/user-attachments/assets/5c793f74-0c73-4992-a1ea-bee8c6231df6)

![image.png](https://github.com/user-attachments/assets/e4be1219-5e37-4ad4-860b-80110815aab8)

**메모리 보호 기법: 한계 레지스터(limit register)**

- 논리 주소의 범위를 벗어나 다른 프로그램의 영역을 침범할 수 있는 명령어 실행을 방지하고,
- 실행 중인 프로그램이 다른 프로그램으로부터 영향을 받지 않도록 메모리를 보호하는 기법

![image.png](https://github.com/user-attachments/assets/c0f8009c-f0c8-49fc-81ff-5ea656d6a405)

## 캐시 메모리

- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위함
- 자주 접근하는 데이터를 저장하여 빠른 데이터 접근 속도를 달성
- CPU와 메인 메모리 사이에 위치하고, 메인 메모리보다 용량이 작음

### 참조 지역성 원리

- 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장한다.
- Cache Hit: 예측한 데이터가 실제로 들어맞아 CPU에서 활용되는 경우
- Cache Miss: Cache에 데이터가 없어서 메모리에서 데이터를 찾아오는 경우. 자주 발생하면 성능 저하
- 캐시는 **참조 지역성의 원리**를 활용해서 **가져올 데이터를 결정**한다.
    1. 시간 지역성: CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
    2. 공간 지역성: CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

# 02. 메인 메모리 관리

## 스와핑(swapping)

- 목적: 가용 메모리 확보
- 사용하지 않는 프로세스를 임시로 보조기억장치 일부 영역으로 내보내고(swap-out),
- 생긴 빈공간에 새로운 프로세스를 올리는 것(swap-in)
- 스왑 영역(swap space, backing store): swap-out 시에 프로세스를 내보내는 영역
- swap-out 되었던 프로세스가 다시 swap-in 될 때는 이전과 다른 물리 주소에 적재될 수 있다.

![image.png](https://github.com/user-attachments/assets/50cbdbcf-7737-4cde-8549-fc0e55026050)

# 03. 연속 메모리 할당

- 프로세스에 연속적인 메모리 공간을 할당하는 방식
- 각 프로세스를 메모리에 담기 위해 메모리는 공간을 미리 분할해 둔다.
- Hole: 메모리가 할당되지 않은 영역

![image (5)](https://github.com/user-attachments/assets/13d4a4e7-c490-46c8-970c-95754b2587f7)

## **고정 분할 방식**

- 물리 메모리를 **영구적으로** 여러 개의 분할로 나누고,
- 각 분할에 하나의 프로세스를 적재한다.
- 분할의 크기는 모두 동일할 수도, 다를 수도 있다.

### **단점**

- 동시에 메모리에 올릴 수 있는 프로그램 수가 고정되어 있음
- 수행할 수 있는 프로그램의 최대 크기가 제한됨
- **외부 단편화, 내부 단편화 문제**가 발생할 수 있음

## 가변 분할 방식

- 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기와 개수가 동적으로 변하는 방식
- 내부 단편화 문제는 발생 x
- 외부 단편화 문제는 발생할 수 있음

### 동적 메모리 할당 문제

- 가변 분할 방식에서, 프로세스가 물리 메모리에 적재될 위치를 결정하는 문제
1. **최초 적합(First-fit):** Hole을 순서대로 탐색하다가 최초로 발견한 공간에 적재
2. **최적 적합(Best-fit):** 적재할 프로세스보다 크기가 큰 Hole 중에서 가장 작은 Hole에 적재
3. **최악 적합(Worst-fit):** 가장 큰 Hole에 할당
    - 가장 넓은 영역에 작은 프로세스부터 적재할 목적으로 사용
    - 외부 단편화의 크기를 줄이기 위함

## 단편화

- 프로세스들이 메모리에서 swap-in과 swap-out을 반복하면서 가용 메모리(hole)가 작은 조각으로 나뉘는 현상

### 내부 단편화

- 분할의 크기 > 프로세스의 크기
- 남는 공간만큼 메모리 낭비 발생

![image (6)](https://github.com/user-attachments/assets/8bf057b5-bc5e-41bc-ad50-3659f250881c)

### 외부 단편화

- 분할의 크기 < 프로세스의 크기
- hole의 총 공간을 계산했을 때 프로세스가 들어갈 수 있는 크기임에도 불구하고 hole이 연속되지 않아 사용할 수 없는 경우

![image (7)](https://github.com/user-attachments/assets/15877674-4587-429f-99a1-5411e1377219)

**해결방안**

- **압축(Compaction)**
    - 프로세스가 사용하는 공간을 한쪽으로 몰아서 공간을 확보하는 방법
    - 프로세스 위치 변경으로 인한 오버헤드 발생, 효율이 좋지 않음
- **통합(Coalescing)**
    - 분산된 메모리 공간을 인접해 있는 것끼리 통합시켜 큰 메모리 공간으로 합치는 방법
    - 압축은 재배치, 통합은 인접한 것들끼리 합침

# 04. 불연속 메모리 할당

- 각 프로세스를 분산하여 메모리에 할당

## 페이징(Paging)

- 프로세스와 메모리를 동일한 크기의 조각으로 나누는 방식
- 조각의 크기가 모두 같기 때문에 메모리가 해제되면 그 자리에 바로 다른 데이터를 적재할 수 있다.
- 프로세스 크기가 페이지 크기보다 작을 수 있음 → 내부 단편화

## 세그멘테이션(Segmentation)

- 프로세스 크기에 맞춰(논리적 내용을 기반으로) 물리 메모리와 가상 메모리를 분할하는 방식
- 프로세스는 세그먼트의 집합으로 나뉘는데, 일반적으로 각 세그먼트의 크기는 같지 않다.
- 물리 메모리에 적재:
    - 페이징과 유사하게 세그먼트 테이블을 통해 적재한다.
    - 대신, 세그먼트의 크기는 일정하지 않기 때문에 세그먼트 테이블에는 limit 정보가 주어짐
    - CPU에서 해당 세그먼트의 크기를 넘는 주소가 들어오면(=limit보다 offset의 크기가 크면) 인터럽트가 발생, 프로세스 강제종료
- 외부 단편화 문제 발생
    
    → 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생하는 것이었는데, segmentation에서도 세그먼트의 크기가 다양하기 때문에 원인이 같다.
    

![image.png](https://github.com/user-attachments/assets/49f51b25-b8b6-4886-a12e-c839ccbc811d)

## 혼용 기법(paged segmentation)

- 프로세스를 세그먼트 단위로 나누고, 이를 다시 페이지 단위로 나누는 것
- 페이징에서, 프로세스의 논리 관계와 상관없이 물리 크기로 분할하기 때문에 코드의 안정성이 떨어질 수 있다는 단점을 해결할 수 있음
- 주소 변환을 두 번 거친다: CPU → 세그먼트 테이블 → 페이지 테이블

# 05. 자주 나오는 질문

## 메모리 단편화란 무엇인가?

메모리의 빈 공간이나 데이터가 여러 개의 조각으로 나뉘는 현상을 말합니다. 메모리 할당과 해제를 반복하면 프로세스를 적재할 수 없을 만큼 작은 가용 메모리가 여러 곳에 나뉘어 분포하게 됩니다. 이러한 가용 메모리 공간이 모이면 총 공간은 프로세스가 적재될 수 있는 크기임에도 불구하고, 실제로 사용할 수 없게 됩니다.

## 메모리 단편화의 해결방법은?

메모리 압축과 통합 기법으로 해결할 수 있습니다. 압축 기법은 프로세스가 점유하고 있는 메모리 공간을 한쪽으로 몰아서 단편화로 인해 분산되어 있는 메모리 공간을 하나로 합치는 기법입니다. 통합 기법은 분산된 메모리 공간 중 인접해 있는 것끼리 합쳐서 큰 메모리 공간으로 만드는 기법입니다.

## 페이지와 세그멘테이션의 차이는?

둘 다 가상메모리 관리 기법입니다. 페이징은 프로세스를 모두 고정된 크기의 페이지라는 단위로 분할하고, 세그멘테이션은 논리적 내용을 바탕으로 세그먼트라는 단위로 분할합니다. 페이징은 물리 메모리 또한 페이지와 같은 크기를 가진 프레임이라는 단위로 분할하여 물리 메모리가 연속적이지 않더라도 프로세스를 할당할 수 있습니다.<br> 

페이징은 외부 단편화를 해결할 수 있지만 페이지 크기보다 프로세스 크기가 작은 경우 외부 단편화가 발생할 수 있고, 세그멘테이션은 내부 단편화를 해결할 수 있지만 세그먼트가 같은 크기가 아니기 때문에 세그먼트를 물리 메모리에 적재하고 내리는 과정에서 외부 단편화가 발생할 수 있습니다.

## 메모리 할당 알고리즘의 정의와 종류는?

프로세스를 메모리에 적재할 때 단편화를 줄이기 위해 사용하는 알고리즘입니다. 종류로는 first fit, best fit, worst fit이 있습니다.<br>

first fit은 메모리를 순서대로 탐색하다가 프로세스 크기에 맞는 공간을 발견하는 즉시 할당하는 방식입니다. best fit은 메모리의 처음부터 끝까지 확인한 후, 해당 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 할당합니다. worst fit은 메모리의 전체 공간 중 가장 큰 가용 영역에 할당하는 방법입니다.

# 사진 출처

ABRAHAM, SILBERSCHATZ et al. Operating System Concepts, Wiley, 2018 <br>
[What is Fragmentation in Operating System?](https://www.geeksforgeeks.org/what-is-fragmentation-in-operating-system/)
