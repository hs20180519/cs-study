# 가상 메모리

- 물리 메모리의 크기보다 큰 프로세스를 수행하기 위해 사용하는 기술이다.

### 기본 아이디어

- 프로세스의 모든 부분이 물리 메모리에 올라갈 필요는 없음
    
    → 실행에 필요한 부분만 물리 메모리에 올라가 있으면 프로세스는 실행 가능하다.
    

→ 이를 통해 한정된 메모리에서 여러 프로세스를 실행시킬 수 있다.

### 물리 주소와 논리(가상) 주소

- 물리 주소
    - 프로세스가 실제 배치되는 메모리상의 위치
    - 컴퓨터의 물리 메모리를 접근할 때 사용
- 가상 주소
    - 프로세스가 참조하는 주소
    - 프로세스가 메모리에 적재될 때 할당되는 가상의(독자적인) 위치
- 가상 메모리는 논리 주소를 다루기 때문에, 논리 주소와 물리 주소의 매핑이 필요하다.
- 매핑을 거치면 프로세스가 물리 메모리에 접근이 가능해진다.

## 물리 메모리 할당

- 연속 메모리 할당 방식: 프로세스를 통째로 메모리에 할당하는 방식
- 불연속 메모리 할당 방식: 프로세스를 분산하여 메모리에 할당

# 페이징

- 불연속 메모리 할당 방식 중 하나로, 고정된(동일한) 크기로 프로세스를 분할
- 페이지: 프로세스 분할 단위
- 프로세스가 점유할 메모리 공간을 각 페이지로 분할하여 물리 메모리에 올린다.
- 프로세스가 현재 참조하고 있는 페이지가 물리 메모리에 있다면 그 프로세스는 수행될 수 있다.

## 프레임

- 물리 메모리 공간을 페이지와 같은 크기로 분할한 고정 크기 블록이다.
- 페이지가 하나의 프레임을 할당받으면 물리 메모리에 위치하게 되며,
- 프레임을 할당받지 못한 페이지들은 외부 저장장치(Backing store)에 저장된다.

## demand paging(요구 페이징)

paging 방식을 사용하면 프로세스에서 나눠진 페이지를 언제 물리 메모리에 올려놓을지에 대한 정책이 필요하다.

demand paging은 프로그램 실행 도중에 요청되는 페이지만 물리 메모리에 적재하는 방식이다.

<aside>
💡 동작과정

1. CPU는 물리 메모리를 확인하여 페이지가 없으면 trap을 발생시켜 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.
4. page fault이면, 현재 물리 메모리에 비어 있는 프레임이 있는지 찾는다.
5. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 업데이트한다.
6. 중단되었던 CPU를 다시 시작한다.
</aside>

# 페이지 교체 알고리즘

- 요구 페이징을 실행할 때, 현재 물리 메모리에 비어 있는 프레임이 없는 경우 현재 메모리에 올라가 있는 페이지를 스왑 영역으로 내보내고 새로운 페이지를 물리 메모리에 로드해야 한다.
- 페이지 교체 알고리즘은 이러한 상황에서 어떤 페이지를 내보낼 것인지 결정하는 알고리즘이다.

## FIFO (first-in-first-out)

- 가장 오래된 페이지부터 우선적으로 교체
- 가장 간단함
- 성능은 보장되지 않음

## OPT (Optimal)

- 가장 오랫동안 사용하지 않은 페이지부터 우선적으로 교체
- 가장 낮은 page-fault 발생 비율을 보장하는 이론상 최적의 알고리즘
- 앞으로 적재할 page 번호를 미리 다 알고 있어야 하는데 알 수 없으므로, 실제 구현 불가능함

## LRU (Least Recently Used)

- 최근에 가장 적게 사용된(가장 오랜 시간 동안 참조되지 않은) 페이지부터 우선적으로 교체
- 구현방법
  - Counter: 마지막으로 접근 요청된 시점을 기록
  - Queue: 한 번 사용된 페이지를 큐의 가장 위로 이동

## LFU (Least Frequent Used)

- 사용 빈도가 가장 적은 페이지부터 우선적으로 교체
- 사용 빈도를 기록해 두어야 하고, 가장 적은 프레임을 찾아야 하는 오버헤드 있음

## NUR (Not Used Recently)

- 최근에 사용하지 않은 페이지부터 우선적으로 교체
