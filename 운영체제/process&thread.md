



# 00. 프로그램
어떤 작업을 위해 컴퓨터에서 실행할 수 있는 파일.
실행하지 않은 상태에서는 그저 정적인 코드 덩어리

프로그램을 실행시키면 파일이 컴퓨터 메모리에 올라가고, 운영체제로부터 자원을 할당받는다.

프로그램은 저장 장치에는 있지만 메모리에 올라가 있지 않다.

ex)  `*.exe`


| 프로세스 | 스레드 |
| --- | --- |
| 운영체제로부터 자원을 할당받은 **작업의 단위** | 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위** |


# 01. 프로세스(Process)
실행된 프로그램, 운영체제로부터 시스템 자원(메모리, CPU 등)을 할당받는 **작업의 단위**

각각의 프로세스는 운영체제에서 독립적인 메모리 공간을 할당받으며, 서로 간섭하지 않고 독립적으로 실행된다.

ex ) 웹 브라우저에서 여러 탭을 열면 각 탭이 별도의 프로세스로 실행되어, 하나의 탭이 비정상 종료되더라도 다른 탭에는 영향을 주지 않는다.

![title](https://d1lic7t7i99g4n.cloudfront.net/photo/kta9k567.png)   



## 프로세스의 자원 구조
4가지 영역으로 구성된다.
![title](https://velog.velcdn.com/images/zunzero/post/f7dbae0f-a1a5-4722-bca6-0b34db512568/image.png)   

코드 영역(Code / Text) : 프로그래머가 작성한 프로그램 함수들의 코드를 기계어 형태로 저장

데이터 영역(Data) : 코드가 실행되면서 사용하는 전역 변수나 각종 데이터 저장 

스택 영역(Stack) : 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시 자료를 저장. 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 즉, 프로세스가 실행되는 동안 크기가 변화하는 **동적 메모리 영역**. 

힙 영역(Heap) : 생성자, 인스턴스와 같은 동적으로 할당되는 데이터 저장. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다. 프로세스가 실행되는 동안 크기가 변화하는 **동적 메모리 영역**.

## 프로세스의 자원 공유
프로세스는 각각 운영체제로부터 독립적인 메모리를 할당받기 때문에, 자원 공유를 위해 별도의 방법이 필요하다.

1. IPC(Inter-Process Communication) 
2. LPC(Local inter-Process Communication)


## PCB (Process Control Block)
PCB 는 운영체제가 프로세스를 표현한 자료구조로, **특정 프로세스에 대한 정보**를 갖고 있다. 
각 프로세스가 생성될때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB 는 제거된다. 



# 02. 스레드(Thread)
**프로세스 내**에서, 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**

하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위 를 말한다.

여러 스레드는 같은 프로세스 내에서 자원을 공유하여 효율적인 처리를 가능하게 한다.

ex) 웹 브라우저의 렌더링 엔진과 자바스크립트 엔진은 서로 다른 스레드로 실행되어, 하나의 스레드가 작업 중이더라도 다른 스레드가 계속해서 사용자 입력을 처리할 수 있다.


## 스레드의 자원 공유
스레드는 프로세스로부터 별도의 stack을 할당받고, 나머지 세 개의 메모리(heap, code, data) 공간은 공유 자원으로써 **다른 스레드와 공유**한다.

독립적인 stack을 가졌다는 것은, 독립적인 함수 호출이 가능하다는 뜻이다.


## Context Switching
CPU는 한번에 하나의 프로세스만 실행 가능하다. 하지만 하나의 작업이 완료될 때까지 기다리는 문제를 해결하기 위해, 실제로는 CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 데(동시성) 이 과정을 **Context Switching**라 한다.

Context Switching은 필연적으로 CPU 시간과 메모리 리소스를 사용하기 때문에, 너무 잦은 전환은 시스템 성능을 저하시킬 수 있는데 이를 **오버헤드**라 한다.





# 03. 멀티 프로세스 vs 멀티 스레드
멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다.
하지만 멀티 스레드는 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험이 있다.

멀티 프로세스는 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다.
하지만 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높다.

ex) 웹 서버의 경우, 각 요청을 처리하는 데 멀티 스레드를 사용하면 빠른 응답 속도를 유지할 수 있다. 
반면, 멀티 프로세스를 사용하면 하나의 요청이 실패해도 전체 서버가 다운되지 않는 장점이 있다.


#### 동기화 문제
스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신 부담이 적어서 응답 시간이 빠르다.

반면, 자원을 공유하기 때문에 필연적으로 **동기화 문제**가 발생할 수 있으며, 교착상태를 주의해야 한다.

**동기화 문제란?**
멀티스레드를 사용하면 각각의 스레드 중 어떤 것이 먼저 실행될지 알 수 없다. 따라서 공유 자원에 접근했을 때 문제가 발생할 수 있다.

#### 데드락(교착)
 컴퓨터 시스템에서 두 개 이상의 프로세스나 스레드가 서로 자원을 요청하며 무한히 대기하는 상태. 
 
 데드락이 발생하면 각 프로세스나 스레드가 필요한 자원을 획득하지 못한 채 무기한으로 멈추게 되며, 시스템이 교착 상태에 빠지게 된다.
 
**데드락 해결**

자원 할당 순서 부여: 특정 순서로만 자원을 요청하게 하여 순환 대기를 방지하는 방법

타임아웃: 일정 시간 동안 자원을 획득하지 못하면 요청을 포기하고 자원을 해제하는 방법

# 04. 자주 나오는 질문

## Q. 프로세스와 스레드 차이에 대해 설명해주세요.
프로세스는 메모리 상에서 실행 중인 프로그램을 의미하며, 운영체제로부터 독립적인 자원을 할당받아 실행되는 작업의 단위입니다. 
반면, 스레드는 프로세스 내에서 실행되는 흐름의 단위로, 프로세스가 할당받은 자원을 이용해 작업을 수행합니다. 
프로세스는 서로 독립된 메모리 공간을 가지지만, 스레드는 동일한 프로세스 내에서 자원을 공유합니다. 
이로 인해 스레드는 통신 비용이 적고, Context Switching이 상대적으로 빠르지만, 동기화 문제가 발생할 수 있는 단점이 있습니다.

## Q. 멀티 프로세스와 멀티 스레드 차이에 대해 설명해주세요.
멀티 프로세스는 각각의 프로세스가 독립적인 메모리 공간을 할당받아 실행되기 때문에, 프로세스 간 자원 공유가 어렵고, Context Switching 비용이 큽니다. 
그러나 하나의 프로세스가 실패해도 다른 프로세스에는 영향을 주지 않아 안정성이 높습니다. 

반면, 멀티 스레드는 동일한 프로세스 내에서 자원을 공유하여 실행되므로 자원 공유의 비용이 적고, Context Switching이 빠릅니다. 
하지만 자원 공유로 인한 동기화 문제가 발생할 수 있으며, 하나의 스레드가 실패하면 전체 프로세스에 영향을 미칠 수 있습니다.

## Q. 멀티스레드 프로그래밍에서 동기화 문제란 무엇인가요?
동기화 문제는 여러 스레드가 동일한 자원을 동시에 접근하여 발생하는 문제입니다. 
예를 들어, 두 개의 스레드가 동시에 같은 변수를 수정하려고 할 때, 각 스레드가 변수의 값을 예기치 않게 덮어쓰게 되어 결과적으로 잘못된 값이 저장될 수 있습니다. 
(이러한 문제를 방지하기 위해서는 락(Lock), 세마포어(Semaphore), 모니터(Monitor) 같은 동기화 기법을 사용하여 스레드 간 자원 접근을 제어해야 합니다.)

## Q. Context Switching이란 무엇인가요?
Context Switching은 CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다음 프로세스나 스레드의 상태를 불러와 실행하는 과정을 말합니다. 
CPU는 한 번에 하나의 작업만 수행할 수 있기 때문에, 여러 작업을 동시에 수행하는 것처럼 보이기 위해 빠르게 프로세스나 스레드를 전환하면서 작업을 진행합니다. 

## Q. 멀티스레드 환경에서 교착상태(Deadlock)가 발생할 수 있는 상황을 설명해 주세요.
교착상태는 두 개 이상의 스레드가 서로가 소유하고 있는 자원을 기다리며 무한히 대기하는 상황입니다. 
예를 들어, 스레드 A가 자원 1을 점유하고 자원 2를 기다리고 있고, 동시에 스레드 B가 자원 2를 점유하고 자원 1을 기다리는 경우, 두 스레드는 서로의 자원을 기다리며 무한 대기 상태에 빠지게 됩니다. 
이를 방지하기 위해서는 자원 할당 순서를 정해주는 방법이나, 타임아웃 기법을 사용하는 것이 좋습니다.




