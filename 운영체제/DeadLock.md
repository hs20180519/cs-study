## 01. 데드락 (DeadLock, 교착 상태)

![title](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F243E89355714C26E28)   


데드락은 
**멀티 프로그래밍 환경**에서 주로 발생하는 문제이다. 

**프로세스가 필요로 하는 자원을 할당받지 못해** 더 이상 작업을 진행하지 못하는 상태를 의미하고, 이는 시스템에서 한정된 공유 자원을 **여러 프로세스가 동시에 사용**하려 할 때 발생할 수 있다. 




<br>

## 02. 데드락 (Dead lock)의 발생 조건

교착 상태는 아래 **네 가지 조건을 모두 만족해야만 발생**한다.


### 1) 상호 배제 (Mutual exclusion)
자원은 한 번에 한 프로세스만이 사용할 수 있다.

### 2) 점유 대기 (Hold and wait)

자원을 점유한 상태에서 다른 자원을 기다리는 프로세스가 자원을 반납하지 않고 계속 점유한 채로 대기하는 상태를 의미한다. 

예를 들어, P1이 자원 R1을 보유하면서 R2를 기다리고, 동시에 P2가 R2를 보유하면서 R1을 기다리면 문제가 발생할 수 있다.

### 3) 비선점 (No preemption)

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.  

### 4) 순환 대기 (Circular wait)

자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다.

 ex) 프로세스 p0, p1, ... , pn이 있을 때 p0은 p1을 기다리고 p1은 p2를 기다리고, ... , pn은 p0을 기다린다. 


![title](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH2XYm%2FbtrfWL1ukSu%2FTzA4phzq2YxvkVEKWQrUu0%2Fimg.png)   

왼쪽 그래프는 Deadlock이지만, 오른쪽 그래프는 Deadlock이 아니다. 

P2가 언젠가 끝나게 되어 instance 1개가 free 되면 P1은 R1을 점유할 수 있고 P3는 R1의 두번째 resource를 가져다 쓸 수 있기 때문이다.

<br>

**자원 할당 그래프에서 데드락 판단 기준**
- 그래프에 cycle이 없다면 모든 경우에 deadlock이 아니다.
- 그래프에 cycle이 있고 모든 Resouce Block에 자원이 하나씩만 있다면 반드시 deadlock 상태이다.
- 그래프에 cycle이 있지만 모든 Resoucr Block의 자원이 하나씩만 있는 것이 아니라면 (여러개가 있는 Block이 존재한다면) deadlock일 수도 있고 아닐수도 있다. 


<br>

## 03. 데드락 (Dead lock) 처리

Deadlock문제를 해결하기 위한 방법으로는 대표적으로 미리 예방하는 방법(Prevention)과 Deadlock이 발생하지 않도록 피하는 방법(Avoidance), 그리고 발생했을 때 처리하는 방법(Detection and Recovery), 무시하는 방법(Ignorance) 총 네 방법으로 나뉜다. 

 <br>


### (1) 교착 상태 예방(Prevention)

자원을 할당할 때 Deadlock의 **4가지 필요조건 중 어느 하나가 만족되지 않도록** 하는 방식

- 상호배제 부정 : 여러 프로세스가 공유 자원 사용

- 점유대기 부정 : 프로세스 실행전 모든 자원을 할당(다 가지고 시작)

- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납(다 반납하고 시작)

- 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
 
 

하지만 이렇게 미리 Deadlock을 방지하는 방식은 효율성과 처리량을 감소시키고, Starvation이 발생할 수 있다. 
 
 
### (2) 교착 상태 회피(Deadlock Avoidance)

Deadlock이 발생할 가능성이 있는 경우엔 아예 자원을 할당하지 않는 방식이다. 


회피 방식은 자원 할당 시 교착 상태가 발생할 위험이 있는 경우 자원을 할당하지 않는 방식이다. 대표적인 알고리즘으로는 **은행원 알고리즘(Banker's Algorithm)** 이 있다.

#### 은행원 알고리즘 

시스템이 자원을 안전하게 할당할 수 있을 때만 자원을 할당한다. 안전 상태는 시스템이 자원을 할당해도 모든 프로세스가 완료될 수 있는 상태를 의미한다.
 
즉, 총 **요청 자원의 수가 남은 자원의 수보다 적은 프로세스만 선택하여 수행**한다. 


<br>


### (3) 교착 상태 해결(Deadlock Detection and Recovery)

데드락이 발생하면 이를 탐지하고 해결하는 방식이다. 

자원 할당 그래프를 통해 데드락 상태를 **탐지**하고, 탐지된 경우 **자원을 선점하거나 교착 상태에 빠진 프로세스를 강제로 종료**하여 시스템을 **복구**한다.

자원을 선점할 땐 어떤 프로세스를 종료시킬지 결정(Selecting a victim)하고, Deadlock이 발생하기 전 상태로 돌아가(Rollback) 프로세스를 재시작한다.

 이 때 동일한 프로세스가 계속해서 victim으로 선정되는 경우 Starvation이 발생할 수도 있는데, 이는 Rollback 된 횟수를 저장함으로써 해결할 수 있다. 



<br>

### (4) 교착 상태 무시(Deadlock Ignorance)

Deadlock이 일어나지 않는다고 생각하고 **아무런 조치도 취하지 않는 방식**이다.

언제 발생할 지 모르는 Deadlock에 대한 조치 자체가 Deadlock보다 큰 오버헤드일 수 있기 때문에 아예 관리하지 않는 것을 말한다.

대신 시스템에 Deadlock이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 사람이 직접 프로세스를 죽이는 등의 방법으로 대처한다. 

ex) UNIX, Windows 등
 

## 04. 자주 나오는 질문

### 1. 데드락이란 무엇인가요?

데드락은 여러 프로세스가 자원을 점유한 상태에서 서로 다른 자원을 기다리며 더 이상 진행할 수 없는 상태를 말합니다. 이는 주로 멀티 프로그래밍 환경에서 발생하며, 교착 상태에 빠진 프로세스는 외부 개입 없이 실행 상태로 돌아갈 수 없습니다.


### 2. 데드락 발생 조건에는 무엇이 있나요?

데드락이 발생하려면 네 가지 조건이 모두 만족해야 합니다.

자원을 한 번에 하나의 프로세스만 사용할 수 있는 상호 배제, 
자원을 점유한 프로세스가 다른 자원을 요청하며, 기존 자원을 놓지 않고 계속 보유하는 점유 대기, 비선점, 프로세스들이 자원을 순환적으로 기다리는 순환 대기가 있습니다.


### 3. 데드락을 방지하는 방법에는 무엇이 있나요?

데드락을 방지하기 위한 방법으로는 교착 상태의 네 가지 발생 조건 중 하나 이상을 제거하는 방법이 있습니다.

### 4. 데드락을 회피하는 방법은 무엇인가요?

데드락을 회피하는 방법 중 대표적으로는 은행원 알고리즘이 있습니다.

은행원 알고리즘은 프로세스가 자원을 요청할 때 시스템이 안전한 상태(Safe State)를 유지할 수 있는 경우에만 자원을 할당합니다.

이 때, 안전 상태란 시스템이 모든 프로세스에게 필요한 자원을 차례로 할당하여 모든 프로세스가 정상적으로 완료될 수 있는 상태를 의미합니다. 

### 5. 데드락이 발생할 가능성을 무시하는 경우는 어떤 시스템에서 사용되나요?
데드락 관리의 오버헤드가 큰 경우, 일부 시스템에서는 데드락이 발생하지 않는다고 가정하고 운영합니다. 
예를 들어, UNIX나 Windows와 같은 시스템은 데드락을 무시하고 있으며, 데드락이 발생하면 관리자가 수동으로 문제를 해결하는 방식을 사용합니다.

### 6. 데드락 상태에서의 기아(Starvation) 문제를 설명해 주세요.

기아 상태는 특정 프로세스가 필요한 자원을 오랫동안 할당받지 못해 무기한 대기하는 상태를 말합니다. 데드락을 방지하거나 회피하는 과정에서 자원이 특정 프로세스에게만 할당되지 않으면 기아 상태가 발생할 수 있습니다. 이를 방지하기 위해, 자원의 할당 순서를 조정하거나 대기 시간이 긴 프로세스에게 우선적으로 자원을 할당하는 방식이 사용됩니다.




<hr>

출처: https://hoit1302.tistory.com/139

출처: https://rebro.kr/177 [Rebro의 코딩 일기장:티스토리]

출처: https://jwprogramming.tistory.com/12 [개발자를 꿈꾸는 프로그래머:티스토리]
