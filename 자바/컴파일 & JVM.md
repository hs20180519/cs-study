# 01. JAVA의 컴파일 과정

![image](https://github.com/user-attachments/assets/f268e3a3-9798-4d0d-9736-6b655d0da7ff)

1. 개발자가 자바 소스코드(.java)를 작성
2. 자바 컴파일러가 .java 파일을 읽어 바이트코드(.class)코드로 컴파일
    - .class는 컴퓨터는 읽을 수 없고, JVM은 읽을 수 있는 코드
3. .class를 JVM의 클래스로더(Class Loader)애개 전달
4. 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩, 링크하여 런타임 데이터 영역(Runtime  Data Area의 Method Area), 즉 JVM의 메모리에 올림
5. 실행 엔진(Execution Engine)이 JVM 메모리에 올라온 바이트코드를 명령어 단위로 하나씩 가져와 실행.
    
    **실행 엔진의 두 가지 방식**
    
    1. 인터프리터
        - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
        - 하나하나의 실행은 빠르지만 전체적인 실행 속도가 느림
    2. JIT 컴파일러
        - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고, 바이너리 코드로 직접 실행
        - 인터프리터의 단점을 보완하기 위해 도입된 방식
        - 바이너리 코드로 변경한 이후에는 해당 메서드를 더 이상 인터프리팅하지 않음
        - 속도가 느리지만, 캐시를 사용하여 한번 컴파일한 이후에는 빠르게 수행됨

# 02. JVM

- 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공
    
    → **자바가 OS에 독립적이라는 특성**을 가질 수 있는 이유
    
- 다른 프로그램을 실행시키는 것이 목적
    1. 자바 프로그램이 어느 기기나 OS 상에서도 실행될 수 있도록 하는 것
    2. 프로그램 메모리를 관리하고 최적화하는 것

## 클래스 로더(Class Loader)

- 동적 로딩: 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 자바의 특성
- 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더

### 동작과정(클래스 로딩 순서)

1. 로드(Load): 바이트 코드를 JVM의 메소드 영역에 저장
2. 링크(Link)
    1. 검증: 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사
        
        = 로드된 바이트코드가 JVM에서 실행될 수 있는 형식인지 검증
        
    2. 준비: 정적 변수를 위한 메모리 할당, 기본값 초기화
    3. 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경하여 실제 메모리에 연결
        - 심볼릭 레퍼런스: .class 파일에 저장된 참조는 문자열, 메소드 시그니처 등
        - 다이렉트 참조: 메모리 주소나 실행 시 참조 가능한 형태
3. 초기화(Initialization): 클래스 변수들을 적절한 값으로 초기화(static 필드 등)

### 특징

**계층 구조**

- 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성됨
- 취상위: 부트스트랩 클래스 로더

![image (1)](https://github.com/user-attachments/assets/4b432dc9-bbbb-482d-8391-76c26717345d)

**위임 모델**

- 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작
- 클래스를 로드할 때: 클래스 로더 캐시, 상위 클래스, 자기 자신 순으로 확인

**가시성(visibility) 제한**

- 하위 클래스 로더는 상위 클래스 로더를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없음
- (상위 → 하위 가능, 하위 → 상위 불가능)

**언로드(unload) 불가**

- 클래스 로더는 클래스 로드만 가능하고 언로드는 불가능
- 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있음

**네임스페이스(namespace)**

- 각 클래스 로더들이 가지고 있는 공간
- 로드된 클래스를 보관하는 용도
- 위임 모델을 통해서 상위 클래스 로더를 확인할 때, 확인하는 공간이 네임스페이스
- 식별자 역할을 하는 FQCN(Fully Qualified Class Name)이라는 게 있음

## 런타임 데이터 영역(Runtime Data Area)

- JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역

![image (2)](https://github.com/user-attachments/assets/86d358cd-4e48-4078-8f05-8144919f9838)

- 스레드마다 생성
    - PC 레지스터
    - JVM 스택
    - 네이티브 메서드 스택
- 모든 스레드가 공유
    - 힙(heap)
    - 메서드 영역(Method area)

**PC 레지스터**

- 현재 수행 중인 명령의 주소를 가리킴
- 자바가 아닌 다른 언어의 메소드를 수행하고 있는 경우에는 undefined 상태가 됨
- 스레드가 시작될 때 생성됨

**JVM 스택**

- 스택 프레임이라는 구조체를 저장하는 스택
- 예외 발생 시에 `printStackTrace()` 로 출력되는 stack trace의 각 라인 하나가 스택 프레임
- 원시타입 변수는 스택 영역에 직접 값을 가지는 반면,
- 참조타입 변수는 heap이나 메소드 영역의 객체 주소를 가짐

<img width="423" alt="image (3)" src="https://github.com/user-attachments/assets/6be78169-89ec-4759-ae5f-ce9fd9fbf888" />

**스택 프레임**

- 현재 실행 중인 메소드 상태 정보를 저장하는 구조체
- JVM에서 메서드가 수행될 때마다 스택 프레임이 하나씩 생성됨
- 생성되면 JVM 스택에 추가되고, 메서드가 종료되면 제거
- 각 스택 프레임은 다음에 대한 참조를 가짐:
    - 지역변수 배열: 메서드가 속한 클래스 인스턴스의 this 레퍼런스, 메서드에 전달된 파라미터, 메서드의 지역 변수
    - 피연산자 스택: 메서드의 실제 작업 공간. 데이터 교환, 다른 메서드 호출 결과를 push/pop
    - 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀

**네이티브 메서드 스택**

<img width="648" alt="image (4)" src="https://github.com/user-attachments/assets/08668f2a-fa2a-4a09-954f-ef8a1a4f397f" />

- 자바 외 언어로 작성된 네이티브 코드를 실행하기 위한 스택
- JNI를 통해 호출하는 코드(C/C++ 등)를 수행하기 위한 스택
- 네이티브 메서드 스택은 네이티브 코드로 되어 있는 함수의 호출을 자바 프로그램 내에서도 직접 수행할 수 있고, 그 결과를 받아올 수도 있는 이유

**JNI(Java Native Interface)**

- 자바가 다른 언어로 만들어진 애플리케이션과 상호작용할 수 있는 인터페이스를 제공하는 프로그램
- JVM이 Native Method를 적재하고 수행할 수 있도록 만듬

**메서드 영역**

- 모든 스레드가 공유하는 영역을, JVM이 시작될 때 생성됨
- JVM이 읽은 각각의 클래스와 인터페이스에 대한 정보를 보관:
    - 런타임 상수 풀, 필드와 메서드 정보, static 변수, 메서드의 바이트코드

**런타임 상수 풀(Runtime Constant Pool)**

- JVM 동작의 핵심 역할을 수행
- 런타임 상수 풀은 다음 정보를 담고 있는 테이블:
    - 각 클래스와 인터페이스의 상수
    - 메서드와 필드에 대한 모든 참조
- 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리 상의 주소를 찾아서 참조

**힙**

- JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시에 동적할당하여 사용하는 영역
    
    → 레퍼런스 타입(`new`로 생성되는 클래스와 인스턴스 변수, 배열 타입 등)이 저장되는 곳
    
- 힙의 참조 주소는 스택이 갖고 있음
    
    → 해당 객체를 통해서만 힙 영역에 있는 인스턴스를 핸들링할 수 있음
    

<img width="709" alt="image (5)" src="https://github.com/user-attachments/assets/ad1283d4-1ef9-409a-834a-dbd074927434" />

- 객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시 GC의 대상

## 실행 엔진(Execution Engine)

- 클래스 로더를 통해 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽고 실행하는 역할
- 자바 바이트코드를 명령어 단위로 읽어서 실행
- 바이트코드의 명령어 : OpCode(1byte) + 추가 피연산자
- 하나의 OpCode를 가져와서 피연산자와 함께 작업 수행하고, 다음 OpCode를 수행하는 식
- 바이트코드 → 네이티브 코드 로 변경하는 방식: 인터프리터, JIT 컴파일러
- JIT 컴파일러의 컴파일 과정은 인터프리팅 방식보다 훨씬 오래 걸리므로, 한 번만 실행되는 코드는 인터프리팅이 유리
    
    → JIT 컴파일러를 사용하는 JVM은 해당 메서드가 얼마나 자주 수행되는지 체크하여 일정 정도를 넘을 때에만 컴파일 수행
    

<img width="709" alt="image (5)" src="https://github.com/user-attachments/assets/ad1283d4-1ef9-409a-834a-dbd074927434" />

# 03. 참고자료

https://steady-snail.tistory.com/67#%EC%9E%90%EB%B0%94_%EC%BD%94%EB%93%9C(JAVA_Code)_%EC%8B%A4%ED%96%89_%EA%B3%BC%EC%A0%95

https://d2.naver.com/helloworld/1230

[☕ JVM 내부 구조 & 메모리 영역 💯 총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8#jit_%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%ACjust-in-time_compiler)
