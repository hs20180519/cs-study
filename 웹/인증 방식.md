# 00. 인증(Authentication)과 인가(Authorization)

서비스 보안을 다룰 때 가장 기본적인 두 개념은 **인증(Authentication)**과 **인가(Authorization)**이다. 이 두 개념은 서로 밀접하게 연관되어 있지만, 분명히 구분되는 역할을 가진다.

## 인증 (Authentication)

- *“당신이 누구인지 증명하는 절차”*
- 사용자의 신원을 확인하는 과정
- 주로 ID/PW, 생체 인식, 소셜 로그인, 인증 토큰 등을 사용
- 예: "이 사용자가 정말 로그인한 사용자 본인인가?"

### 예시

- 사용자가 아이디와 비밀번호를 입력하여 본인임을 증명
- Google 계정으로 로그인
- JWT 토큰을 통해 사용자 정보 확인

## 인가 (Authorization)

- *"당신이 어떤 권한을 갖고 있는지 판단하는 절차"*
- 인증이 완료된 사용자가 수행할 수 있는 작업이나 접근할 수 있는 리소스를 결정
- 주로 역할(Role), 권한(Permission), 정책 등을 기준으로 접근 제어
- 예: "이 사용자가 관리자 페이지에 접근할 수 있는가?"

### 예시

- 일반 사용자는 게시글 수정 불가, 관리자는 가능
- 특정 API는 관리자만 접근 가능
- OAuth의 Scope 기반 리소스 접근 제한

### 요약

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
| --- | --- | --- |
| 의미 | 사용자의 신원을 확인 | 사용자 권한을 확인 |
| 순서 | 먼저 수행됨 | 인증 이후 수행됨 |
| 예시 | 로그인, 지문 인식 등 | 관리자 권한, 파일 접근 등 |

# 01. API Key

서비스들이 거대해짐에 따라 기능들을 분리하기 시작하였고, 이를 위해 모듈이나 애플리케이션 간의 공유와 독립성을 보장하기 위한 기능들이 등장하기 시작했다.
그 중 가장 먼저 등장하고, 지금도 널리 보편적으로 사용되는 기술이 **API Key**이다.

### 개념 및 사용 배경

- 클라이언트가 서버의 특정 API를 호출하기 위해 발급받은 Key를 이용해 요청을 인증함
- 사용자는 인증하지 않으며, 단순히 애플리케이션 또는 요청자를 식별함
- 외부 공개 API, 제휴 서비스 API 등에 자주 사용됨 (예: Google Maps API)

### 동작 방식

1. 서버에서 API Key를 발급
2. 클라이언트는 요청 시 해당 Key를 HTTP Header 또는 URL Query에 포함하여 보냄
3. 서버는 Key의 유효성을 검사하고 요청을 처리함

### 장점

- 구현이 단순함
- 빠르게 적용 가능함
- 외부 애플리케이션 사용을 제한하거나 식별할 수 있음

### 문제점

- **보안에 취약**: Key가 노출되면 누구나 사용할 수 있음
- **사용자 인증 불가**: 클라이언트를 식별할 뿐, 실제 사용자에 대한 인증은 불가능
- Key에 대한 권한 제어 기능이 제한적임

---

# 02. OAuth 2.0

사용자가 자신의 인증 정보를 직접 제공하지 않고, 제3자 애플리케이션이 제한된 범위 내에서 리소스에 접근할 수 있도록 허용하는 인증 프레임워크

### 개념 및 사용 배경

- 기존 API Key 방식의 보안 한계, 사용자 정보 노출 문제를 해결하기 위해 등장
- 권한 위임(Delegation)에 초점을 맞춘 인증 방식
- Google, Facebook, Kakao 등의 **소셜 로그인**에 활용됨

### 주요 개념

- **리소스 소유자 (Resource Owner)**: 사용자
- **클라이언트 (Client)**: 제3자 애플리케이션
- **인증 서버 (Authorization Server)**: 인증 및 토큰 발급 담당
- **리소스 서버 (Resource Server)**: 보호된 자원 제공

### 동작 방식

**Authorization Code Flow (가장 일반적)**

1. 사용자가 클라이언트에 로그인 요청
2. 클라이언트가 인증 서버로 리디렉션
3. 사용자가 인증 후 Authorization Code를 발급받음
4. 클라이언트가 Authorization Code를 인증 서버에 보내 Access Token을 발급받음
5. Access Token을 사용해 리소스 서버에 요청

### 장점

- 사용자 인증 및 권한 분리를 잘 지원함
- 민감 정보 전달이 없음 (토큰 기반)
- 권한 범위 지정 가능 (scope)

### 문제점

- 구현이 비교적 복잡함
- Access Token이 노출되면 위험함
- 클라이언트 상태 유지가 필요한 경우 있음

---

# 03. JWT (JSON Web Token)

JWT는 JSON 기반의 토큰 포맷으로, 인증된 사용자 정보를 서버가 아닌 **토큰 자체에 담아 클라이언트가 소지**하고 다니는 방식

### 개념 및 사용 배경

- 세션 기반 인증의 단점을 보완하기 위해 등장
- 서버 상태를 유지하지 않아도 되는 **Stateless 인증** 방식으로, 주로 RESTful API 인증에 사용됨

### 동작 방식

1. 사용자가 로그인 요청
2. 서버가 사용자 인증 후 JWT를 발급하여 클라이언트에 전달
3. 클라이언트는 JWT를 로컬 저장소에 저장 (Cookie 또는 LocalStorage)
4. 이후 요청 시 JWT를 HTTP Header에 포함하여 전송
5. 서버는 JWT를 검증하여 사용자 요청 처리

### 토큰 구조

- **Header**: 타입, 알고리즘
- **Payload**: 클레임(사용자 정보, 권한 등)
- **Signature**: 토큰 위변조 방지를 위한 서명

### 장점

- 서버가 상태를 저장하지 않아 확장성이 높음
- 빠른 인증 처리
- 다양한 클레임을 담아 확장 가능

### 문제점

- 탈취 시 보안 취약 (특히 로컬스토리지 사용 시)
- 토큰 무효화가 어려움 (서버에 저장하지 않기 때문)
- 클레임에 민감 정보가 담길 경우 위험함 (암호화 필요)

# 04. 자주 나오는 질문 정리

### 인증과 인가의 특징과 차이점에 대해서 설명해주세요.
인증은 Authentication으로 사용자가 서비스에 가입되어 있는지
확인하는 과정으로 웹서비스의 경우 아이디와 패스워드를 사용해
인증 과정을 수행합니다. 로그인 과정에서 주로 진행되며,
사용자가 서비스에 접근할 수 있는지 확인합니다.

인가는 Authorization으로 인증된 사용자에 대해
자원이나 작업에 대한 권한을 확인하는 과정으로
로그인 과정에서 진행되는 인증과 달리
인가는 사용자가 request를 할 때마다 서버에서
권한을 확인합니다.

### 세션 기반 인증과 토큰 기반 인증의 차이에 대해 얘기해주세요
세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고,

토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.
